---
title: '服务器变慢诊断命令'
date: 2021-09-15 14:59:00
tags: [linux]
published: true
hideInList: false
feature: /post-images/Um55sd5Z3.png
isTop: false
---
### top命令详解

![](https://tinaxiawuhao.github.io/post-images/1631692082043.png)

**第一行，任务队列信息，同 uptime 命令的执行结果**

> 系统时间：07:27:05
>
> 运行时间：up 1:57 min,
>
> 当前登录用户： 3 user
>
> 负载均衡(uptime) load average: 0.00, 0.00, 0.00
>
>    average后面的三个数分别是1分钟、5分钟、15分钟的负载情况。
>
> load average数据是每隔5秒钟检查一次活跃的进程数，然后按特定算法计算出的数值。如果这个数除以逻辑CPU的数量，结果高于5的时候就表明系统在超负荷运转了

**第二行，Tasks — 任务（进程）**

> 总进程:150 total, 运行:1 running, 休眠:149 sleeping, 停止: 0 stopped, 僵尸进程: 0 zombie

**第三行，cpu状态信息**

> 0.0%us【user space】— 用户空间占用CPU的百分比。
>
> 0.3%sy【sysctl】— 内核空间占用CPU的百分比。
>
> 0.0%ni【】— 改变过优先级的进程占用CPU的百分比
>
> 99.7%id【idolt】— 空闲CPU百分比
>
> 0.0%wa【wait】— IO等待占用CPU的百分比
>
> 0.0%hi【Hardware IRQ】— 硬中断占用CPU的百分比
>
> 0.0%si【Software Interrupts】— 软中断占用CPU的百分比

**第四行,内存状态**

>  1003020k total,  234464k used,  777824k free,  24084k buffers【缓存的内存量】

**第五行，swap交换分区信息**

> 2031612k total,   536k used, 2031076k free,  505864k cached【缓冲的交换区总量】

> 备注：
>
> 可用内存=free + buffer + cached
>
> 对于内存监控，在top里我们要时刻监控第五行swap交换分区的used，如果这个数值在不断的变化，说明内核在不断进行内存和swap的数据交换，这是真正的内存不够用了。
>
> 第四行中使用中的内存总量（used）指的是现在系统内核控制的内存数，
>
> 第四行中空闲内存总量（free）是内核还未纳入其管控范围的数量。
>
> 纳入内核管理的内存不见得都在使用中，还包括过去使用过的现在可以被重复利用的内存，内核并不把这些可被重新使用的内存交还到free中去，因此在linux上free内存会越来越少，但不用为此担心。

**第六行，空行**

**第七行以下：各进程（任务）的状态监控**

> PID — 进程id
> USER — 进程所有者
> PR — 进程优先级
> NI — nice值。负值表示高优先级，正值表示低优先级
> VIRT — 进程使用的虚拟内存总量，单位kb。VIRT=SWAP+RES
> RES — 进程使用的、未被换出的物理内存大小，单位kb。RES=CODE+DATA
> SHR — 共享内存大小，单位kb
> S —进程状态。D=不可中断的睡眠状态 R=运行 S=睡眠 T=跟踪/停止 Z=僵尸进程
> %CPU — 上次更新到现在的CPU时间占用百分比
> %MEM — 进程使用的物理内存百分比
> TIME+ — 进程使用的CPU时间总计，单位1/100秒
> COMMAND — 进程名称（命令名/命令行）

**详解**

> **VIRT：virtual memory usage 虚拟内存
> **1、进程“需要的”虚拟内存大小，包括进程使用的库、代码、数据等
> 2、假如进程申请100m的内存，但实际只使用了10m，那么它会增长100m，而不是实际的使用量
>
> **RES：resident memory usage 常驻内存**
> 1、进程当前使用的内存大小，但不包括swap out
> 2、包含其他进程的共享
> 3、如果申请100m的内存，实际使用10m，它只增长10m，与VIRT相反
> 4、关于库占用内存的情况，它只统计加载的库文件所占内存大小
>
> **SHR：shared memory 共享内存**
> 1、除了自身进程的共享内存，也包括其他进程的共享内存
> 2、虽然进程只使用了几个共享库的函数，但它包含了整个共享库的大小
> 3、计算某个进程所占的物理内存大小公式：RES – SHR
> 4、swap out后，它将会降下来
>
> **DATA**
> 1、数据占用的内存。如果top没有显示，按f键可以显示出来。
> 2、真正的该程序要求的数据空间，是真正在运行中要使用的。
>
> **top 运行中可以通过 top 的内部命令对进程的显示方式进行控制。内部命令如下：**
> s – 改变画面更新频率
> l – 关闭或开启第一部分第一行 top 信息的表示
> t – 关闭或开启第一部分第二行 Tasks 和第三行 Cpus 信息的表示
> m – 关闭或开启第一部分第四行 Mem 和 第五行 Swap 信息的表示
> N – 以 PID 的大小的顺序排列表示进程列表
> P – 以 CPU 占用率大小的顺序排列进程列表
> M – 以内存占用率大小的顺序排列进程列表
> h – 显示帮助
> n – 设置在进程列表所显示进程的数量
> q – 退出 top
> s – 改变画面更新周期

### vmstat命令详解

vmstat命令是最常见的Linux/Unix监控工具，可以展现给定时间间隔的服务器的状态值,包括服务器的CPU使用率，内存使用，虚拟内存交换情况,IO读写情况。这个命令是我查看Linux/Unix最喜爱的命令，一个是Linux/Unix都支持，二是相比top，我可以看到整个机器的CPU,内存,IO的使用情况，而不是单单看到各个进程的CPU使用率和内存使用率(使用场景不一样)。

一般vmstat工具的使用是通过两个数字参数来完成的，第一个参数是采样的时间间隔数，单位是秒，第二个参数是采样的次数，如:

```
root@ubuntu:~# vmstat 2 1
procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa
 1  0      0 3498472 315836 3819540    0    0     0     1    2    0  0  0 100  0
```

2表示每个两秒采集一次服务器状态，1表示只采集一次。

实际上，在应用过程中，我们会在一段时间内一直监控，不想监控直接结束vmstat就行了,例如:

```
root@ubuntu:~# vmstat 2  
procs -----------memory---------- ---swap-- -----io---- -system-- ----cpu----
 r  b   swpd   free   buff  cache   si   so    bi    bo   in   cs us sy id wa
 1  0      0 3499840 315836 3819660    0    0     0     1    2    0  0  0 100  0
 0  0      0 3499584 315836 3819660    0    0     0     0   88  158  0  0 100  0
 0  0      0 3499708 315836 3819660    0    0     0     2   86  162  0  0 100  0
 0  0      0 3499708 315836 3819660    0    0     0    10   81  151  0  0 100  0
 1  0      0 3499732 315836 3819660    0    0     0     2   83  154  0  0 100  0
```

这表示vmstat每2秒采集数据，一直采集，直到我结束程序，这里采集了5次数据我就结束了程序。

**参数详解**

> **r** 表示运行队列(就是说多少个进程真的分配到CPU)，我测试的服务器目前CPU比较空闲，没什么程序在跑，当这个值超过了CPU数目，就会出现CPU瓶颈了。这个也和top的负载有关系，一般负载超过了3就比较高，超过了5就高，超过了10就不正常了，服务器的状态很危险。top的负载类似每秒的运行队列。如果运行队列过大，表示你的CPU很繁忙，一般会造成CPU使用率很高。
>
> **b** 表示阻塞的进程,这个不多说，进程阻塞，大家懂的。
>
> **swpd** 虚拟内存已使用的大小，如果大于0，表示你的机器物理内存不足了，如果不是程序内存泄露的原因，那么你该升级内存了或者把耗内存的任务迁移到其他机器。
>
> **free**  空闲的物理内存的大小，我的机器内存总共8G，剩余3415M。
>
> **buff**  Linux/Unix系统是用来存储，目录里面有什么内容，权限等的缓存，我本机大概占用300多M
>
> **cache** cache直接用来记忆我们打开的文件,给文件做缓冲，我本机大概占用300多M(这里是Linux/Unix的聪明之处，把空闲的物理内存的一部分拿来做文件和目录的缓存，是为了提高 程序执行的性能，当程序使用内存时，buffer/cached会很快地被使用。)
>
> **si** 每秒从磁盘读入虚拟内存的大小，如果这个值大于0，表示物理内存不够用或者内存泄露了，要查找耗内存进程解决掉。我的机器内存充裕，一切正常。
>
> **so** 每秒虚拟内存写入磁盘的大小，如果这个值大于0，同上。
>
> **bi** 块设备每秒接收的块数量，这里的块设备是指系统上所有的磁盘和其他块设备，默认块大小是1024byte，我本机上没什么IO操作，所以一直是0，但是我曾在处理拷贝大量数据(2-3T)的机器上看过可以达到140000/s，磁盘写入速度差不多140M每秒
>
> **bo** 块设备每秒发送的块数量，例如我们读取文件，bo就要大于0。bi和bo一般都要接近0，不然就是IO过于频繁，需要调整。
>
> **in** 每秒CPU的中断次数，包括时间中断
>
> **cs** 每秒上下文切换次数，例如我们调用系统函数，就要进行上下文切换，线程的切换，也要进程上下文切换，这个值要越小越好，太大了，要考虑调低线程或者进程的数目,例如在apache和nginx这种web服务器中，我们一般做性能测试时会进行几千并发甚至几万并发的测试，选择web服务器的进程可以由进程或者线程的峰值一直下调，压测，直到cs到一个比较小的值，这个进程和线程数就是比较合适的值了。系统调用也是，每次调用系统函数，我们的代码就会进入内核空间，导致上下文切换，这个是很耗资源，也要尽量避免频繁调用系统函数。上下文切换次数过多表示你的CPU大部分浪费在上下文切换，导致CPU干正经事的时间少了，CPU没有充分利用，是不可取的。
>
> **us** 用户CPU时间，我曾经在一个做加密解密很频繁的服务器上，可以看到us接近100,r运行队列达到80(机器在做压力测试，性能表现不佳)。
>
> **sy** 系统CPU时间，如果太高，表示系统调用时间长，例如是IO操作频繁。
>
> **id** 空闲 CPU时间，一般来说，id + us + sy = 100,一般我认为id是空闲CPU使用率，us是用户CPU使用率，sy是系统CPU使用率。
>
> **wt** 等待IO CPU时间。



### pid命令详解

pidstat是sysstat工具的一个命令，用于监控全部或指定进程的cpu、内存、线程、设备IO等系统资源的占用情况。pidstat首次运行时显示自系统启动开始的各项统计信息，之后运行pidstat将显示自上次运行该命令以后的统计信息。用户可以通过指定统计的次数和时间来获得所需的统计信息。

pidstat 的用法：

```
pidstat [ 选项 ] [ <时间间隔> ] [ <次数> ]
```

如下图：

![](https://tinaxiawuhao.github.io/post-images/1631692116794.png)

 

**常用的参数：**

- -u：默认的参数，显示各个进程的cpu使用统计
- -r：显示各个进程的内存使用统计
- -d：显示各个进程的IO使用情况
- -p：指定进程号
- -w：显示每个进程的上下文切换情况
- -t：显示选择任务的线程的统计信息外的额外信息
- -T { TASK | CHILD | ALL }
  这个选项指定了pidstat监控的。TASK表示报告独立的task，CHILD关键字表示报告进程下所有线程统计信息。ALL表示报告独立的task和task下面的所有线程。
  注意：task和子线程的全局的统计信息和pidstat选项无关。这些统计信息不会对应到当前的统计间隔，这些统计信息只有在子线程kill或者完成的时候才会被收集。
- -V：版本号
- -h：在一行上显示了所有活动，这样其他程序可以容易解析。
- -I：在SMP环境，表示任务的CPU使用率/内核数量
- -l：显示命令名和所有参数



```
pidstat
pidstat -u -p ALL
```

pidstat 和 pidstat -u -p ALL 是等效的。
pidstat 默认显示了所有进程的cpu使用率。

![](https://tinaxiawuhao.github.io/post-images/1631692161313.png)


 

**参数详解**

- PID：进程ID

- %usr：进程在用户空间占用cpu的百分比

- %system：进程在内核空间占用cpu的百分比

- %guest：进程在虚拟机占用cpu的百分比

- %CPU：进程占用cpu的百分比

- CPU：处理进程的cpu编号

- Command：当前进程对应的命令

  

### free命令详解

free 命令显示系统内存的使用情况，包括物理内存、交换内存(swap)和内核缓冲区内存。

![](https://tinaxiawuhao.github.io/post-images/1631692175318.png)

如果加上 -h 选项，输出的结果会友好很多：

![](https://tinaxiawuhao.github.io/post-images/1631692195242.png)

有时我们需要持续的观察内存的状况，此时可以使用 -s 选项并指定间隔的秒数：

```
$ free -h -s 3
```

![](https://tinaxiawuhao.github.io/post-images/1631692210174.png)

上面的命令每隔 3 秒输出一次内存的使用情况，直到你按下 ctrl + c。

由于 free 命令本身比较简单，所以本文的重点会放在如何通过 free 命令了解系统当前的内存使用状况。

**输出说明**
**Mem** 行(第二行)是内存的使用情况。
**Swap** 行(第三行)是交换空间的使用情况。
**total** 列显示系统总的可用物理内存和交换空间大小。
**used** 列显示已经被使用的物理内存和交换空间。
**free** 列显示还有多少物理内存和交换空间可用使用。
**shared** 列显示被共享使用的物理内存大小。
**buff/cache** 列显示被 buffer 和 cache 使用的物理内存大小。
**available** 列显示还可以被应用程序使用的物理内存大小。

### df命令详解

Linux df（英文全拼：disk free） 命令用于显示目前在 Linux 系统上的文件系统磁盘使用情况统计。

**语法**

```
df [选项]... [FILE]...
```

- 文件-a, --all 包含所有的具有 0 Blocks 的文件系统
- 文件--block-size={SIZE} 使用 {SIZE} 大小的 Blocks
- 文件-h, --human-readable 使用人类可读的格式(预设值是不加这个选项的...)
- 文件-H, --si 很像 -h, 但是用 1000 为单位而不是用 1024
- 文件-i, --inodes 列出 inode 资讯，不列出已使用 block
- 文件-k, --kilobytes 就像是 --block-size=1024
- 文件-l, --local 限制列出的文件结构
- 文件-m, --megabytes 就像 --block-size=1048576
- 文件--no-sync 取得资讯前不 sync (预设值)
- 文件-P, --portability 使用 POSIX 输出格式
- 文件--sync 在取得资讯前 sync
- 文件-t, --type=TYPE 限制列出文件系统的 TYPE
- 文件-T, --print-type 显示文件系统的形式
- 文件-x, --exclude-type=TYPE 限制列出文件系统不要显示 TYPE
- 文件-v (忽略)
- 文件--help 显示这个帮手并且离开
- 文件--version 输出版本资讯并且离开

**实例**

显示文件系统的磁盘使用情况统计：

```
# df 
Filesystem     1K-blocks    Used     Available Use% Mounted on 
/dev/sda6       29640780 4320704     23814388  16%     / 
udev             1536756       4     1536752    1%     /dev 
tmpfs             617620     888     616732     1%     /run 
none                5120       0     5120       0%     /run/lock 
none             1544044     156     1543888    1%     /run/shm 
```

第一列指定文件系统的名称，第二列指定一个特定的文件系统1K-块1K是1024字节为单位的总内存。用和可用列正在使用中，分别指定的内存量。

使用列指定使用的内存的百分比，而最后一栏"安装在"指定的文件系统的挂载点。

df也可以显示磁盘使用的文件系统信息：

```
# df test 
Filesystem     1K-blocks    Used      Available Use% Mounted on 
/dev/sda6       29640780    4320600   23814492  16%       / 
```

用一个-i选项的df命令的输出显示inode信息而非块使用量。

```
df -i 
Filesystem      Inodes    IUsed    IFree     IUse% Mounted on 
/dev/sda6      1884160    261964   1622196   14%        / 
udev           212748     560      212188    1%         /dev 
tmpfs          216392     477      215915    1%         /run 
none           216392     3        216389    1%         /run/lock 
none           216392     8        216384    1%         /run/shm 
```

显示所有的信息:

```
# df --total 
Filesystem     1K-blocks    Used    Available Use% Mounted on 
/dev/sda6       29640780 4320720    23814372  16%     / 
udev             1536756       4    1536752   1%      /dev 
tmpfs             617620     892    616728    1%      /run 
none                5120       0    5120      0%      /run/lock 
none             1544044     156    1543888   1%      /run/shm 
total           33344320 4321772    27516860  14% 
```

我们看到输出的末尾，包含一个额外的行，显示总的每一列。

-h选项，通过它可以产生可读的格式df命令的输出：

```
# df -h 
Filesystem      Size  Used   Avail Use% Mounted on 
/dev/sda6       29G   4.2G   23G   16%     / 
udev            1.5G  4.0K   1.5G   1%     /dev 
tmpfs           604M  892K   603M   1%     /run 
none            5.0M     0   5.0M   0%     /run/lock 
none            1.5G  156K   1.5G   1%     /run/shm 
```

我们可以看到输出显示的数字形式的'G'（千兆字节），"M"（兆字节）和"K"（千字节）。

这使输出容易阅读和理解，从而使显示可读的。请注意，第二列的名称也发生了变化，为了使显示可读的"大小"。

### iostat命令详解

用法：iostat [ 选项 ] [ <时间间隔> [ <次数> ]]

常用选项说明：

```
-c：只显示系统CPU统计信息，即单独输出avg-cpu结果，不包括device结果
-d：单独输出Device结果，不包括cpu结果
-k/-m：输出结果以kB/mB为单位，而不是以扇区数为单位
-x:输出更详细的io设备统计信息
interval/count：每次输出间隔时间，count表示输出次数，不带count表示循环输出
```

说明：更多选项使用使用man iostat查看

**实例**

1、iostat，结果为从系统开机到当前执行时刻的统计信息

![](https://tinaxiawuhao.github.io/post-images/1631692226555.png)

输出含义：

  avg-cpu: 总体cpu使用情况统计信息，对于多核cpu，这里为所有cpu的平均值。重点关注iowait值，表示CPU用于等待io请求的完成时间。

  Device: 各磁盘设备的IO统计信息。各列含义如下：

```
Device: 以sdX形式显示的设备名称
tps: 每秒进程下发的IO读、写请求数量
KB_read/s: 每秒从驱动器读入的数据量，单位为K。
KB_wrtn/s: 每秒从驱动器写入的数据量，单位为K。
KB_read: 读入数据总量，单位为K。
KB_wrtn: 写入数据总量，单位为K。
```

2、iostat -x -k -d 1 2。每隔1S输出磁盘IO的详细详细，总共采样2次。

![](https://tinaxiawuhao.github.io/post-images/1631692235192.png)

 

以上各列的含义如下：

```
rrqm/s: 每秒对该设备的读请求被合并次数，文件系统会对读取同块(block)的请求进行合并
wrqm/s: 每秒对该设备的写请求被合并次数
r/s: 每秒完成的读次数
w/s: 每秒完成的写次数
rkB/s: 每秒读数据量(kB为单位)
wkB/s: 每秒写数据量(kB为单位)
avgrq-sz:平均每次IO操作的数据量(扇区数为单位)
avgqu-sz: 平均等待处理的IO请求队列长度
await: 平均每次IO请求等待时间(包括等待时间和处理时间，毫秒为单位)
svctm: 平均每次IO请求的处理时间(毫秒为单位)
%util: 采用周期内用于IO操作的时间比率，即IO队列非空的时间比率
```

 重点关注参数

> 1、iowait% 表示CPU等待IO时间占整个CPU周期的百分比，如果iowait值超过50%，或者明显大于%system、%user以及%idle，表示IO可能存在问题。
>
> 2、avgqu-sz 表示磁盘IO队列长度，即IO等待个数。
>
> 3、await 表示每次IO请求等待时间，包括等待时间和处理时间
>
> 4、svctm 表示每次IO请求处理的时间
>
> 5、%util 表示磁盘忙碌情况，一般该值超过80%表示该磁盘可能处于繁忙状态。

### ifstat命令详解

统计网络接口流量状态

下载

```shell
wget http://gael.roualland.free.fr/ifstat/ifstat-1.1.tar.gz
```

编译安装

```shell
tar -zxvf ifstat-1.1.tar.gz
cd ifstat-1.1
./configure            
make
make install # 默认会安装到/usr/local/bin/目录中
```

`注释`：执行which ifstat输出/usr/local/bin/ifstat

选项

>  -l 监测环路网络接口（lo）。缺省情况下，ifstat监测活动的所有非环路网络接口。经使用发现，加上-l参数能监测所有的网络接口的信息，而不是只监测 lo的接口信息，也就是说，加上-l参数比不加-l参数会多一个lo接口的状态信息。
>  -a 监测能检测到的所有网络接口的状态信息。使用发现，比加上-l参数还多一个plip0的接口信息，搜索一下发现这是并口（网络设备中有一 个叫PLIP (Parallel Line Internet Protocol). 它提供了并口...）
>  -z 隐藏流量是无的接口，例如那些接口虽然启动了但是未用的
>  -i 指定要监测的接口,后面跟网络接口名
>  -s 等于加-d snmp:[comm@][#]host[/nn]] 参数，通过SNMP查询一个远程主机
>  -h 显示简短的帮助信息
>  -n 关闭显示周期性出现的头部信息（也就是说，不加-n参数运行ifstat时最顶部会出现网络接口的名称，当一屏显示不下时，会再一次出现接口的名称，提示我们显示的流量信息具体是哪个网络接口的。加上-n参数把周期性的显示接口名称关闭，只显示一次）
>  -t 在每一行的开头加一个时间 戳（能告诉我们具体的时间）
>  -T 报告所有监测接口的全部带宽（最后一列有个total，显示所有的接口的in流量和所有接口的out流量，简单的把所有接口的in流量相加,out流量相 加）
>  -w  用指定的列宽，而不是为了适应接口名称的长度而去自动放大列宽
>  -W 如果内容比终端窗口的宽度还要宽就自动换行
>  -S 在同一行保持状态更新（不滚动不换行）注：如果不喜欢屏幕滚动则此项非常方便，与bmon的显示方式类似
>  -b 用kbits/s显示带宽而不是kbytes/s
>  -q 安静模式，警告信息不出现
>  -v 显示版本信息
>  -d 指定一个驱动来收集状态信息

 **实例**
 默认使用

```shell
 #ifstat
       eth0                eth1       
 KB/s in  KB/s out   KB/s in  KB/s out
    0.07      0.20      0.00      0.00
    0.07      0.15      0.58      0.00
```

默认ifstat不监控回环接口，显示的流量单位是KB。

```shell
ifstat -tT
  time           eth0                eth1                eth2                eth3               Total      
HH:MM:ss   KB/s in  KB/s out   KB/s in  KB/s out   KB/s in  KB/s out   KB/s in  KB/s out   KB/s in  KB/s out
16:53:04      0.84      0.62   1256.27   1173.05      0.12      0.18      0.00      0.00   1257.22   1173.86
16:53:05      0.57      0.40      0.57      0.76      0.00      0.00      0.00      0.00      1.14      1.17
16:53:06      1.58      0.71      0.42      0.78      0.00      0.00      0.00      0.00      2.01      1.48
16:53:07      0.57      0.40      1.91      2.61      0.00      0.00      0.00      0.00      2.48      3.01
16:53:08      0.73      0.40    924.02   1248.91      0.00      0.00      0.00      0.00    924.76   1249.31
```

监控所有网络接口

```shell
ifstat -a
        lo                 eth0                eth1       
 KB/s in  KB/s out   KB/s in  KB/s out   KB/s in  KB/s out
    0.00      0.00      0.28      0.58      0.06      0.06
    0.00      0.00      1.41      1.13      0.00      0.00
    0.61      0.61      0.26      0.23      0.00      0.00
```


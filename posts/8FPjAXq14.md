---
title: '消息服务：MQ使用场景与选型对比'
date: 2022-07-20 20:45:01
tags: [springCloud,MQ]
published: true
hideInList: false
feature: /post-images/8FPjAXq14.png
isTop: false
---
MQ的使用场景，引入MQ后的注意事项以及MQ的选型对比。

![](https://tianxiawuhao.github.io/post-images/1659012365390.png)

### MQ的使用场景

MQ的英文全称是Message Queue，翻译成中文就是消息队列，队列实现了先进先出（FIFO）的消息模型。通过消息队列，我们可以实现多个进程之间的通信，例如，可以实现多个微服务之间的消息通信。MQ的最简模型就是生产者生产消息，将消息发送到MQ，消息消费者订阅MQ，消费消息。

![](https://tianxiawuhao.github.io/post-images/1659012373243.png)



MQ的使用场景通常包含：**异步解耦、流量削峰**。

#### 异步解耦

关于异步的场景，我们这里举一个用户下单成功后，向用户发送通知消息，为用户增加积分和优惠券的场景。

##### 同步耦合场景分析

如果是同步调用的场景，则具体业务为：当用户提交订单成功后，订单系统会调用通知系统为用户发送消息通知，告知用户下单成功，订单系统调用积分系统为用户增加积分，订单系统调用优惠券系统为用户增加优惠券。整个调用流程如下所示。

![](https://tianxiawuhao.github.io/post-images/1659012384187.png)

通过上图的分析，可以看到，用户调用订单系统下单时，总共会经过8个步骤。并且每个步骤都是紧密耦合在一起串行执行，如下所示。

![](https://tianxiawuhao.github.io/post-images/1659012392280.png)


此时，订单系统、通知系统、积分系统和优惠券系统是紧密耦合在一起的，订单系统下单、通知系统发通知、积分系统发积分和优惠券系统发优惠券，四个任务全部完成后，才会给用户返回提交订单的结果信息。

用户提交订单花费的总时间为调用订单系统下单的时间+订单系统调用通知系统发送通知的时间+订单系统调用积分系统发放积分的时间+订单系统调用优惠券系统发放优惠券的时间。

**注意：这里为了更好的说明系统之间串行执行的问题，忽略了网络的延迟时间。**

这种串行化的系统执行方式，在高并发、大流量场景下是不可取的。另外，如果其中一个系统异常或者宕机，势必会影响到订单系统的可用性。在系统维护上，只要任意一个系统的接口发生变动，订单系统的逻辑也要跟着发生变动。

##### 异步解耦场景分析

既然在高并发、大流量场景下使用订单系统直接串行调用通知系统、积分系统和优惠券系统的方式不可取。那我们是否能够使用异步解耦的方式呢。

其实，在用户提交订单的场景中，用户最关心的是自己的订单是否提交成功，由于下单时，订单系统会直接返回是否下单成功的提示。

对于通知、积分和优惠券可以以异步的方式延后一小段时间执行。并且通知系统、积分系统和优惠券系统之间不存在必然的业务关联逻辑，它们之间可以以并行的方式执行。

所以，可以使用MQ将订单系统与通知系统、积分系统和优惠券系统进行解耦，用户调用订单系统的接口下单时，订单系统向数据库写入订单数据后，向MQ写入消息，就可以直接返回给用户下单成功的提示，此时通知系统、积分系统和优惠券系统都订阅MQ中的消息，收到消息后各自执行自身的业务逻辑即可。

![](https://tianxiawuhao.github.io/post-images/1659012401565.png)

当引入MQ进行异步解耦之后，用户调用订单系统的接口下单，订单系统执行完业务逻辑将订单数据入口，会向MQ发送一条消息，随后便直接返回用户下单成功的提示。通知系统、积分系统和优惠券系统会同时订阅MQ中的消息，当收到消息时，它们各自会执行自身的业务逻辑，并且它们是以并行的方式执行各自的业务逻辑。

![](https://tianxiawuhao.github.io/post-images/1659012408903.png)

从执行的时间线上可以看出，当引入MQ进行异步解耦之后，通知系统、积分系统、优惠券系统和订单系统回复响应都是并行执行的，大大提高系统的执行性能。

并且解耦后，任意一个系统异常或者宕机，都不会影响到订单系统的可用性。只要订单系统与其他系统提前约定好发送的消息格式和消息内容，后续任意一个系统的业务逻辑变动，几乎都不会影响到订单系统的逻辑。

#### 流量削峰

MQ在高并发、大流量的场景下可以用作削峰填谷的利器，例如，12306的春运抢票场景、高并发秒杀场景、双十一和618的大促场景等。

在高并发、大流量业务场景下，瞬间会有大量用户的请求涌入系统，如果不对这些流量做处理的话，直接让这些流量进入下游系统，则很可能由于下游系统无法支撑如此高的并发而导致系统崩溃或宕机。为了解决这些问题，可以引入MQ进行流量的削峰填谷。

![](https://tianxiawuhao.github.io/post-images/1659012417620.png)

将流量发送到MQ中后，下游系统根据自身的处理能力进行消费即可。保证了下游系统的高可用性。

### 引入MQ后的注意事项

引入MQ最大的优点就是异步解耦和流量削峰，但是引入MQ后也有很多需要注意的事项和问题，主要包括：系统的整体可用性降低、系统的复杂度变高、引入了消息一致性的问题。

#### 系统的整体可用性降低

在对一个系统进行架构设计时，引入的外部依赖越多，系统的稳定性和可用性就会降低。系统中引入了MQ，部分业务就会出现强依赖MQ的现象，此时，如果MQ宕机，则部分业务就会变得不可用。所以，引入MQ时，我们就要考虑如何实现MQ的高可用。

#### 系统的复杂度变高

引入MQ后，会使之前的同步接口调用变成通过MQ的异步调用，在实际的开发过程中，异步调用会比同步调用复杂的多。并且异步调用出现问题后，重现问题，定位问题和解决问题都会比同步调用复杂的多。

并且引入MQ后，还要考虑如何保证消息的顺序等问题。

#### 消息一致性问题

引入MQ后，不得不考虑的一个问题就是消息的一致性问题。这期间就要考虑如何保证消息不丢失，消息幂等和消息数据处理的幂等性问题。

### MQ选型对比

目前，在行业内使用的比较多的MQ包含RabbitMQ、Kafka和RocketMQ。这里，我将三者的对比简单整理了个表格，如下所示。

| 消息中间件(MQ) | 优点                                                         | 缺点                                                         | 使用场景                                     |
| :------------- | :----------------------------------------------------------- | :----------------------------------------------------------- | :------------------------------------------- |
| RabbitMQ       | 功能全面、消息的可靠性比较高                                 | 吞吐量低，消息大量积累会影响性能，使用的开发语言是erlang，不好定制功能。 | 规模不大的场景                               |
| Kafka          | 吞吐量最高，性能最好，集群模式下高可用                       | 功能上比较单一，会丢失部分数据                               | 日志分析，大数据场景                         |
| RocketMQ       | 吞吐量高，性能高，可用性高，功能全面。使用Java语言开发，容易定制功能。 | 开源版不如阿里云上版，文档比较简单。                         | 几乎支持所有场景，包含大数据场景和业务场景。 |
<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[tianxia]的个人博客">
<meta name="author" content="kveln">
<title>Flink 零基础实战教程：如何计算实时热门商品 | tianxia</title>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.5.0/dist/css/bootstrap.min.css">
<link href="https://cdn.bootcss.com/font-awesome/5.11.2/css/all.min.css" rel="stylesheet">
<link rel="alternate" type="application/rss+xml" title="Flink 零基础实战教程：如何计算实时热门商品 | tianxia » Feed"
  href="https://tinaxiawuhao.github.io/atom.xml">
<link rel="stylesheet"
  href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@9.15.10/build/styles/androidstudio.min.css">
<link href="https://tinaxiawuhao.github.io/styles/main.css" rel="stylesheet">
<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>

<script src="https://cdn.jsdelivr.net/npm/@highlightjs/cdn-assets/highlight.min.js"></script>

<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/css/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="Flink 零基础实战教程：如何计算实时热门商品" />
  <meta property="og:url" content="https://tinaxiawuhao.github.io/post/use-flink-calculate-hot-items/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="tianxia" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tinaxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1653832415555"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tinaxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1653832415555"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://tinaxiawuhao.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://tinaxiawuhao.github.io/tag/1WJzfk7Hi/" class="tag">flink</a>
                
              </span>
              <h1>Flink 零基础实战教程：如何计算实时热门商品</h1>
              <span class="meta">
                Posted on
                2021-04-06，15 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <img class="post-feature-header-image" src="https://tinaxiawuhao.github.io/post-images/use-flink-calculate-hot-items.png" alt="封面图">
          </img>
          
          <p>在上一篇入门教程中，我们已经能够快速构建一个基础的 Flink 程序了。本文会一步步地带领你实现一个更复杂的 Flink 应用程序：实时热门商品。在开始本文前我们建议你先实践一遍上篇文章，因为本文会沿用上文的my-flink-project项目框架。</p>
<p>通过本文你将学到：</p>
<pre><code>1. 如何基于 EventTime 处理，如何指定 Watermark
2. 如何使用 Flink 灵活的 Window API
3. 何时需要用到 State，以及如何使用
4. 如何使用 ProcessFunction 实现 TopN 功能
</code></pre>
<h2 id="实战案例介绍">实战案例介绍</h2>
<p>本案例将实现一个“实时热门商品”的需求，我们可以将“实时热门商品”翻译成程序员更好理解的需求：每隔5分钟输出最近一小时内点击量最多的前 N 个商品。将这个需求进行分解我们大概要做这么几件事情：</p>
<pre><code>* 抽取出业务时间戳，告诉 Flink 框架基于业务时间做窗口
* 过滤出点击行为数据
* 按一小时的窗口大小，每5分钟统计一次，做滑动窗口聚合（Sliding Window）
* 按每个窗口聚合，输出每个窗口中点击量前N名的商品
</code></pre>
<h2 id="数据准备">数据准备</h2>
<p>这里我们准备了一份淘宝用户行为数据集（来自阿里云天池公开数据集，特别感谢）。本数据集包含了淘宝上某一天随机一百万用户的所有行为（包括点击、购买、加购、收藏）。数据集的组织形式和MovieLens-20M类似，即数据集的每一行表示一条用户行为，由用户ID、商品ID、商品类目ID、行为类型和时间戳组成，并以逗号分隔。关于数据集中每一列的详细描述如下：</p>
<table>
<thead>
<tr>
<th>列名称</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>用户ID</td>
<td>整数类型，加密后的用户ID</td>
</tr>
<tr>
<td>商品ID</td>
<td>整数类型，加密后的商品ID</td>
</tr>
<tr>
<td>商品类目ID</td>
<td>整数类型，加密后的商品所属类目ID</td>
</tr>
<tr>
<td>行为类型</td>
<td>字符串，枚举类型，包括(‘pv’, ‘buy’, ‘cart’, ‘fav’)</td>
</tr>
<tr>
<td>时间戳</td>
<td>行为发生的时间戳，单位秒</td>
</tr>
</tbody>
</table>
<p>你可以通过下面的命令下载数据集到项目的 resources 目录下：</p>
<pre><code class="language-sh">$ cd my-flink-project/src/main/resources
$ curl https://raw.githubusercontent.com/wuchong/my-flink-project/master/src/main/resources/UserBehavior.csv &gt; UserBehavior.csv
</code></pre>
<p>这里是否使用 curl 命令下载数据并不重要，你也可以使用 wget 命令或者直接访问链接下载数据。关键是，将数据文件保存到项目的<code>resources</code> 目录下，方便应用程序访问。</p>
<h2 id="编写程序">编写程序</h2>
<p>在 <code>src/main/java/myflink</code> 下创建 <code>HotItems.java</code> 文件：</p>
<pre><code class="language-java">package myflink;

public class HotItems {

  public static void main(String[] args) throws Exception {
    
  }
}
</code></pre>
<p>与上文一样，我们会一步步往里面填充代码。第一步仍然是创建一个 <code>StreamExecutionEnvironment</code>，我们把它添加到 main 函数中。</p>
<pre><code class="language-java">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
// 为了打印到控制台的结果不乱序，我们配置全局的并发为1，这里改变并发对结果正确性没有影响
env.setParallelism(1);
</code></pre>
<h2 id="创建模拟数据源">创建模拟数据源</h2>
<p>在数据准备章节，我们已经将测试的数据集下载到本地了。由于是一个csv文件，我们将使用 <code>CsvInputFormat</code> 创建模拟数据源。</p>
<blockquote>
<p>注：虽然一个流式应用应该是一个一直运行着的程序，需要消费一个无限数据源。但是在本案例教程中，为了省去构建真实数据源的繁琐，我们使用了文件来模拟真实数据源，这并不影响下文要介绍的知识点。这也是一种本地验证 Flink 应用程序正确性的常用方式。</p>
</blockquote>
<p>我们先创建一个 <code>UserBehavior</code> 的 POJO 类（所有成员变量声明成public便是POJO类），强类型化后能方便后续的处理。</p>
<pre><code class="language-java">/** 用户行为数据结构 **/
public static class UserBehavior {
  public long userId;         // 用户ID
  public long itemId;         // 商品ID
  public int categoryId;      // 商品类目ID
  public String behavior;     // 用户行为, 包括(&quot;pv&quot;, &quot;buy&quot;, &quot;cart&quot;, &quot;fav&quot;)
  public long timestamp;      // 行为发生的时间戳，单位秒
}
</code></pre>
<p>接下来我们就可以创建一个 <code>PojoCsvInputFormat</code> 了， 这是一个读取 csv 文件并将每一行转成指定 POJO<br>
类型（在我们案例中是 UserBehavior）的输入器。</p>
<pre><code class="language-java">// UserBehavior.csv 的本地文件路径
URL fileUrl = HotItems2.class.getClassLoader().getResource(&quot;UserBehavior.csv&quot;);
Path filePath = Path.fromLocalFile(new File(fileUrl.toURI()));
// 抽取 UserBehavior 的 TypeInformation，是一个 PojoTypeInfo
PojoTypeInfo&lt;UserBehavior&gt; pojoType = (PojoTypeInfo&lt;UserBehavior&gt;) TypeExtractor.createTypeInfo(UserBehavior.class);
// 由于 Java 反射抽取出的字段顺序是不确定的，需要显式指定下文件中字段的顺序
String[] fieldOrder = new String[]{&quot;userId&quot;, &quot;itemId&quot;, &quot;categoryId&quot;, &quot;behavior&quot;, &quot;timestamp&quot;};
// 创建 PojoCsvInputFormat
PojoCsvInputFormat&lt;UserBehavior&gt; csvInput = new PojoCsvInputFormat&lt;&gt;(filePath, pojoType, fieldOrder);
</code></pre>
<p>下一步我们用 <code>PojoCsvInputFormat</code> 创建输入源。</p>
<pre><code class="language-java">DataStream&lt;UserBehavior&gt; dataSource = env.createInput(csvInput, pojoType);
</code></pre>
<p>这就创建了一个 <code>UserBehavior</code> 类型的 <code>DataStream</code>。</p>
<h2 id="eventtime-与-watermark">EventTime 与 Watermark</h2>
<p>当我们说“统计过去一小时内点击量”，这里的“一小时”是指什么呢？ 在 Flink 中它可以是指 <code>ProcessingTime</code> ，也可以是 <code>EventTime</code>，由用户决定。</p>
<blockquote>
<p>ProcessingTime：事件被处理的时间。也就是由机器的系统时间来决定。<br>
EventTime：事件发生的时间。一般就是数据本身携带的时间。</p>
</blockquote>
<p>在本案例中，我们需要统计业务时间上的每小时的点击量，所以要基于 EventTime 来处理。那么如果让 Flink 按照我们想要的业务时间来处理呢？这里主要有两件事情要做。</p>
<p>第一件是告诉 Flink 我们现在按照 <code>EventTime</code> 模式进行处理，Flink 默认使用 <code>ProcessingTime</code> 处理，所以我们要显式设置下。</p>
<pre><code class="language-java">env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
</code></pre>
<p>第二件事情是指定如何获得业务时间，以及生成 <code>Watermark</code>。<code>Watermark</code> 是用来追踪业务事件的概念，可以理解成 <code>EventTime</code> 世界中的时钟，用来指示当前处理到什么时刻的数据了。由于我们的数据源的数据已经经过整理，没有乱序，即事件的时间戳是单调递增的，所以可以将每条数据的业务时间就当做 <code>Watermark</code>。这里我们用 <code>AscendingTimestampExtractor</code> 来实现时间戳的抽取和 <code>Watermark</code>的生成。</p>
<blockquote>
<p>注：真实业务场景一般都是存在乱序的，所以一般使用</p>
</blockquote>
<pre><code class="language-java">BoundedOutOfOrdernessTimestampExtractor。

DataStream&lt;UserBehavior&gt; timedData = dataSource
    .assignTimestampsAndWatermarks(new AscendingTimestampExtractor&lt;UserBehavior&gt;() {
      @Override
      public long extractAscendingTimestamp(UserBehavior userBehavior) {
        // 原始数据单位秒，将其转成毫秒
        return userBehavior.timestamp * 1000;
      }
    });
</code></pre>
<p>这样我们就得到了一个带有时间标记的数据流了，后面就能做一些窗口的操作。</p>
<h2 id="过滤出点击事件">过滤出点击事件</h2>
<p>在开始窗口操作之前，先回顾下需求“每隔5分钟输出过去一小时内点击量最多的前 N 个商品”。由于原始数据中存在点击、加购、购买、收藏各种行为的数据，但是我们只需要统计点击量，所以先使用 <code>FilterFunction</code> 将点击行为数据过滤出来。</p>
<pre><code class="language-java">DataStream&lt;UserBehavior&gt; pvData = timedData
    .filter(new FilterFunction&lt;UserBehavior&gt;() {
      @Override
      public boolean filter(UserBehavior userBehavior) throws Exception {
        // 过滤出只有点击的数据
        return userBehavior.behavior.equals(&quot;pv&quot;);
      }
    });
</code></pre>
<h2 id="窗口统计点击量">窗口统计点击量</h2>
<p>由于要每隔5分钟统计一次最近一小时每个商品的点击量，所以窗口大小是一小时，每隔5分钟滑动一次。即分别要统计 [09:00, 10:00), [09:05, 10:05), [09:10, 10:10)… 等窗口的商品点击量。是一个常见的滑动窗口需求（Sliding Window）。</p>
<pre><code class="language-java">DataStream&lt;ItemViewCount&gt; windowedData = pvData
    .keyBy(&quot;itemId&quot;)
    .timeWindow(Time.minutes(60), Time.minutes(5))
    .aggregate(new CountAgg(), new WindowResultFunction());
</code></pre>
<p>我们使用<code>.keyBy(&quot;itemId&quot;)</code>对商品进行分组，使用<code>.timeWindow(Time size, Time slide)</code>对每个商品做滑动窗口（1小时窗口，5分钟滑动一次）。然后我们使用<code>.aggregate(AggregateFunction af, WindowFunction wf)</code>做增量的聚合操作，它能使用<code>AggregateFunction</code>提前聚合掉数据，减少 <code>state</code> 的存储压力。较之<code>.apply(WindowFunction wf)</code>会将窗口中的数据都存储下来，最后一起计算要高效地多。<code>aggregate()</code>方法的第一个参数用于</p>
<p>这里的<code>CountAgg</code>实现了<code>AggregateFunction</code>接口，功能是统计窗口中的条数，即遇到一条数据就加一。</p>
<pre><code class="language-java">/** COUNT 统计的聚合函数实现，每出现一条记录加一 */
public static class CountAgg implements AggregateFunction&lt;UserBehavior, Long, Long&gt; {

  @Override
  public Long createAccumulator() {
    return 0L;
  }

  @Override
  public Long add(UserBehavior userBehavior, Long acc) {
    return acc + 1;
  }

  @Override
  public Long getResult(Long acc) {
    return acc;
  }

  @Override
  public Long merge(Long acc1, Long acc2) {
    return acc1 + acc2;
  }
}
</code></pre>
<p><code>.aggregate(AggregateFunction af, WindowFunction wf)</code>的第二个参数<code>WindowFunction</code>将每个 key每个窗口聚合后的结果带上其他信息进行输出。我们这里实现的<code>WindowResultFunction</code>将主键商品ID，窗口，点击量封装成了<code>ItemViewCount</code>进行输出。</p>
<pre><code class="language-java">/** 用于输出窗口的结果 */
public static class WindowResultFunction implements WindowFunction&lt;Long, ItemViewCount, Tuple, TimeWindow&gt; {

  @Override
  public void apply(
      Tuple key,  // 窗口的主键，即 itemId
      TimeWindow window,  // 窗口
      Iterable&lt;Long&gt; aggregateResult, // 聚合函数的结果，即 count 值
      Collector&lt;ItemViewCount&gt; collector  // 输出类型为 ItemViewCount
  ) throws Exception {
    Long itemId = ((Tuple1&lt;Long&gt;) key).f0;
    Long count = aggregateResult.iterator().next();
    collector.collect(ItemViewCount.of(itemId, window.getEnd(), count));
  }
}

/** 商品点击量(窗口操作的输出类型) */
public static class ItemViewCount {
  public long itemId;     // 商品ID
  public long windowEnd;  // 窗口结束时间戳
  public long viewCount;  // 商品的点击量

  public static ItemViewCount of(long itemId, long windowEnd, long viewCount) {
    ItemViewCount result = new ItemViewCount();
    result.itemId = itemId;
    result.windowEnd = windowEnd;
    result.viewCount = viewCount;
    return result;
  }
}
</code></pre>
<p>现在我们得到了每个商品在每个窗口的点击量的数据流。</p>
<h2 id="topn-计算最热门商品">TopN 计算最热门商品</h2>
<p>为了统计每个窗口下最热门的商品，我们需要再次按窗口进行分组，这里根据<code>ItemViewCount</code>中的<code>windowEnd</code>进行<code>keyBy()</code>操作。然后使用 <code>ProcessFunction</code> 实现一个自定义的 TopN 函数 <code>TopNHotItems</code> 来计算点击量排名前3名的商品，并将排名结果格式化成字符串，便于后续输出。</p>
<pre><code class="language-java">DataStream&lt;String&gt; topItems = windowedData
    .keyBy(&quot;windowEnd&quot;)
    .process(new TopNHotItems(3));  // 求点击量前3名的商品
</code></pre>
<p><code>ProcessFunction</code> 是 Flink 提供的一个 <code>low-level API</code>，用于实现更高级的功能。它主要提供了定时器 <code>timer</code> 的功能（支持<code>EventTime</code>或<code>ProcessingTime</code>）。本案例中我们将利用 <code>timer</code> 来判断何时收齐了某个 <code>window</code> 下所有商品的点击量数据。由于 <code>Watermark</code> 的进度是全局的，</p>
<p>在 <code>processElement</code> 方法中，每当收到一条数据<code>（ItemViewCount）</code>，我们就注册一个 <code>windowEnd+1</code>的定时器（Flink 框架会自动忽略同一时间的重复注册）。<code>windowEnd+1</code>的定时器被触发时，意味着收到了<code>windowEnd+1</code>的 <code>Watermark</code>，即收齐了该<code>windowEnd</code>下的所有商品窗口统计值。我们在<code>onTimer()</code> 中处理将收集的所有商品及点击量进行排序，选出 <code>TopN</code>，并将排名信息格式化成字符串后进行输出。</p>
<p>这里我们还使用了 <code>ListState&lt;ItemViewCount&gt;</code> 来存储收到的每条 <code>ItemViewCount</code> 消息，保证在发生故障时，状态数据的不丢失和一致性。<code>ListState</code> 是 Flink 提供的类似 Java List 接口的 State API，它集成了框架的<code>checkpoint</code> 机制，自动做到了 <code>exactly-once</code> 的语义保证。</p>
<pre><code class="language-java">/** 求某个窗口中前 N 名的热门点击商品，key 为窗口时间戳，输出为 TopN 的结果字符串 */
public static class TopNHotItems extends KeyedProcessFunction&lt;Tuple, ItemViewCount, String&gt; {

  private final int topSize;

  public TopNHotItems(int topSize) {
    this.topSize = topSize;
  }

  // 用于存储商品与点击数的状态，待收齐同一个窗口的数据后，再触发 TopN 计算
  private ListState&lt;ItemViewCount&gt; itemState;

  @Override
  public void open(Configuration parameters) throws Exception {
    super.open(parameters);
    // 状态的注册
    ListStateDescriptor&lt;ItemViewCount&gt; itemsStateDesc = new ListStateDescriptor&lt;&gt;(
        &quot;itemState-state&quot;,
        ItemViewCount.class);
    itemState = getRuntimeContext().getListState(itemsStateDesc);
  }

  @Override
  public void processElement(
      ItemViewCount input,
      Context context,
      Collector&lt;String&gt; collector) throws Exception {

    // 每条数据都保存到状态中
    itemState.add(input);
    // 注册 windowEnd+1 的 EventTime Timer, 当触发时，说明收齐了属于windowEnd窗口的所有商品数据
    context.timerService().registerEventTimeTimer(input.windowEnd + 1);
  }

  @Override
  public void onTimer(
      long timestamp, OnTimerContext ctx, Collector&lt;String&gt; out) throws Exception {
    // 获取收到的所有商品点击量
    List&lt;ItemViewCount&gt; allItems = new ArrayList&lt;&gt;();
    for (ItemViewCount item : itemState.get()) {
      allItems.add(item);
    }
    // 提前清除状态中的数据，释放空间
    itemState.clear();
    // 按照点击量从大到小排序
    allItems.sort(new Comparator&lt;ItemViewCount&gt;() {
      @Override
      public int compare(ItemViewCount o1, ItemViewCount o2) {
        return (int) (o2.viewCount - o1.viewCount);
      }
    });
    // 将排名信息格式化成 String, 便于打印
    StringBuilder result = new StringBuilder();
    result.append(&quot;====================================\n&quot;);
    result.append(&quot;时间: &quot;).append(new Timestamp(timestamp-1)).append(&quot;\n&quot;);
    for (int i=0;i&lt;topSize;i++) {
      ItemViewCount currentItem = allItems.get(i);
      // No1:  商品ID=12224  浏览量=2413
      result.append(&quot;No&quot;).append(i).append(&quot;:&quot;)
            .append(&quot;  商品ID=&quot;).append(currentItem.itemId)
            .append(&quot;  浏览量=&quot;).append(currentItem.viewCount)
            .append(&quot;\n&quot;);
    }
    result.append(&quot;====================================\n\n&quot;);

    out.collect(result.toString());
  }
}
</code></pre>
<h2 id="打印输出">打印输出</h2>
<p>最后一步我们将结果打印输出到控制台，并调用env.execute执行任务。</p>
<pre><code class="language-java">topItems.print();
env.execute(&quot;Hot Items Job&quot;);
</code></pre>
<p>运行程序<br>
直接运行 main 函数，就能看到不断输出的每个时间点的热门商品ID。</p>
<figure data-type="image" tabindex="1"><img src="https://tinaxiawuhao.github.io/post-images/1617955791838.png" alt="" loading="lazy"></figure>
<h2 id="更换-kafka-作为数据源">更换 Kafka 作为数据源</h2>
<p>实际生产环境中， 我们的数据流往往是从 Kafka 获取到的。 如果要让代码更贴<br>
近生产实际， 我们只需将 source 更换为 Kafka 即可：</p>
<pre><code class="language-java">val properties = new Properties()
properties.setProperty(&quot;bootstrap.servers&quot;, &quot;localhost:9092&quot;)
properties.setProperty(&quot;group.id&quot;, &quot;consumer-group&quot;)
properties.setProperty(&quot;key.deserializer&quot;,
&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;)
properties.setProperty(&quot;value.deserializer&quot;,
&quot;org.apache.kafka.common.serialization.StringDeserializer&quot;)
properties.setProperty(&quot;auto.offset.reset&quot;, &quot;latest&quot;)
val env = StreamExecutionEnvironment.getExecutionEnvironment
env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)
env.setParallelism(1)
val stream = env
.addSource(new FlinkKafkaConsumer[String](&quot;hotitems&quot;, new SimpleStringSchema(),
properties))
</code></pre>
<p>当然， 根据实际的需要， 我们还可以将 Sink 指定为 Kafka、 ES、 Redis 或其它<br>
存储， 这里就不一一展开实现了</p>
<h2 id="总结">总结</h2>
<p>本文的完整代码可以通过 GitHub 访问到。本文通过实现一个“实时热门商品”的案例，学习和实践了 Flink 的多个核心概念和 API 用法。包括 <code>EventTime</code>、<code>Watermark</code>的使用，<code>State</code> 的使用，<code>Window API</code> 的使用，以及 TopN 的实现。希望本文能加深大家对 Flink 的理解，帮助大家解决实战上遇到的问题。</p>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E5%AE%9E%E6%88%98%E6%A1%88%E4%BE%8B%E4%BB%8B%E7%BB%8D">实战案例介绍</a></li>
<li><a href="#%E6%95%B0%E6%8D%AE%E5%87%86%E5%A4%87">数据准备</a></li>
<li><a href="#%E7%BC%96%E5%86%99%E7%A8%8B%E5%BA%8F">编写程序</a></li>
<li><a href="#%E5%88%9B%E5%BB%BA%E6%A8%A1%E6%8B%9F%E6%95%B0%E6%8D%AE%E6%BA%90">创建模拟数据源</a></li>
<li><a href="#eventtime-%E4%B8%8E-watermark">EventTime 与 Watermark</a></li>
<li><a href="#%E8%BF%87%E6%BB%A4%E5%87%BA%E7%82%B9%E5%87%BB%E4%BA%8B%E4%BB%B6">过滤出点击事件</a></li>
<li><a href="#%E7%AA%97%E5%8F%A3%E7%BB%9F%E8%AE%A1%E7%82%B9%E5%87%BB%E9%87%8F">窗口统计点击量</a></li>
<li><a href="#topn-%E8%AE%A1%E7%AE%97%E6%9C%80%E7%83%AD%E9%97%A8%E5%95%86%E5%93%81">TopN 计算最热门商品</a></li>
<li><a href="#%E6%89%93%E5%8D%B0%E8%BE%93%E5%87%BA">打印输出</a></li>
<li><a href="#%E6%9B%B4%E6%8D%A2-kafka-%E4%BD%9C%E4%B8%BA%E6%95%B0%E6%8D%AE%E6%BA%90">更换 Kafka 作为数据源</a></li>
<li><a href="#%E6%80%BB%E7%BB%93">总结</a></li>
</ul>
</li>
</ul>
</div>
          
              <hr />
            
          
            
            <p class="next-post">上一篇：
                <a href="https://tinaxiawuhao.github.io/post/build-first-flink-application/">
                  <span class="post-title">
                    从零构建第一个 Flink 应用&rarr;
                  </span>
                </a>
              </p>
            
          
            
           <p class="prev-post">下一篇：
                 <a href="https://tinaxiawuhao.github.io/post/gam9PGQCS/">
                   <span class="post-title">
                     第一章 Flink 简介&rarr;
                   </span>
                 </a>
               </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
            <li class="list-inline-item">
              <a href="https://github.com/tinaxiawuhao" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://tinaxiawuhao.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>tianxia</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://tinaxiawuhao.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://tinaxiawuhao.github.io/media/scripts/clean-blog.min.js"></script> -->
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <div id="landlord-parent">
    <div id="landlord">
        <div class="message" style="opacity:0"></div>
        <canvas id="live2d" width="240" height="250" class="live2d"></canvas>
    </div>
</div>

<script type="text/javascript">
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)) {
        //移动端
        console.log("------ 移动端");
    } else {
        console.log("------ PC端 " + navigator.userAgent);

        addScript("https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/js/live2d.js", () => {
            // 加载完成后再loadlive2d
            loadlive2d("live2d", "https://tinaxiawuhao.github.io/media/live2d/assets/tororo.model.json");
        });

        var home_Path = "https://tinaxiawuhao.github.io/";
        addScript("https://tinaxiawuhao.github.io/media/live2d/js/message.js", () => { });
    }

    // 插入js文件，完成后callback
    function addScript(jsfile, callback) {
        var landlord_parent = document.getElementById("landlord-parent");
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = jsfile;
        landlord_parent.appendChild(script);
        script.onload = script.onreadystatechange = function () {
            if (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") {
                script.onload = script.onreadystatechange = null;
                if (callback && typeof callback == "function") {
                    callback(); //window[callback]();如果传递字符串过来 调用window['函数名']() 调用方法
                }
            }
        };
    }
</script>
  
  <script src="https://tinaxiawuhao.github.io/media/scripts/tocScript.js"></script>
</body>

</html>
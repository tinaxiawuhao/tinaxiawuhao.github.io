<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[tianxia]的个人博客">
<meta name="author" content="kveln">
<title>gateway项目整合网关 | tianxia</title>
<link rel="stylesheet" href="https://tinaxiawuhao.github.io/resource/bootstrap.min.css">
<link href="https://tinaxiawuhao.github.io/resource/all.min.css" rel="stylesheet">
<link rel="alternate" type="application/rss+xml" title="gateway项目整合网关 | tianxia » Feed"
  href="https://tinaxiawuhao.github.io/atom.xml">
<link rel="stylesheet"
  href="https://tinaxiawuhao.github.io/resource/androidstudio.min.css">
<link href="https://tinaxiawuhao.github.io/styles/main.css" rel="stylesheet">
<script src="https://tinaxiawuhao.github.io/resource/jquery.min.js"></script>

<script src="https://tinaxiawuhao.github.io/resource/highlight.min.js"></script>

<link rel="stylesheet" href="https://tinaxiawuhao.github.io/resource/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="gateway项目整合网关" />
  <meta property="og:url" content="https://tinaxiawuhao.github.io/post/PN2nvPeue/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="tianxia" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tinaxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1660659241544"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tinaxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1660659241544"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://tinaxiawuhao.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://tinaxiawuhao.github.io/tag/PvdavFGm6/" class="tag">springCloud</a>
                
              </span>
              <h1>gateway项目整合网关</h1>
              <span class="meta">
                Posted on
                2022-07-10，23 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <img class="post-feature-header-image" src="https://tinaxiawuhao.github.io/post-images/PN2nvPeue.png" alt="封面图">
          </img>
          
          <h2 id="项目整合网关">项目整合网关</h2>
<p>我们需要在项目中增加一个服务网关模块shop-gateway，在服务网关模块中实现网关的能力。此时，我们的项目中就会有用户微服务、商品微服务、订单微服务和服务网关。</p>
<figure data-type="image" tabindex="1"><img src="https://tinaxiawuhao.github.io/post-images/1658668356973.png" alt="" loading="lazy"></figure>
<h3 id="新建网关模块">新建网关模块</h3>
<p>在项目中新建shop-gateway模块，新增网关模块后项目的结构如下图所示。</p>
<figure data-type="image" tabindex="2"><img src="https://tinaxiawuhao.github.io/post-images/1658668389660.png" alt="" loading="lazy"></figure>
<h3 id="初步整合springcloud-gateway">初步整合SpringCloud Gateway</h3>
<p>（1）在服务网关shop-gateway模块的pom.xml文件中添加如下依赖。</p>
<pre><code class="language-java">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>（2）在服务网关shop-gateway模块的resources目录下新建application.yml文件，并在文件中添加如下配置信息。</p>
<pre><code class="language-java">server:
  port: 10001
spring:
  application:
    name: server-gateway
  cloud:
    gateway:
      globalcors:
        cors-configurations:
          '[/**]':
            allowedOrigins: &quot;*&quot;
            allowedMethods: &quot;*&quot;
            allowCredentials: true
            allowedHeaders: &quot;*&quot;

      routes:
        - id: user-gateway
          uri: http://localhost:8060
          order: 1
          predicates:
            - Path=/server-user/**
          filters:
            - StripPrefix=1

        - id: product-gateway
          uri: http://localhost:8070
          order: 1
          predicates:
            - Path=/server-product/**
          filters:
            - StripPrefix=1

        - id: order-gateway
          uri: http://localhost:8080
          order: 1
          predicates:
            - Path=/server-order/**
          filters:
            - StripPrefix=1
</code></pre>
<p>我们重点来看下 <code>spring.cloud.gateway</code> 节点下的配置。</p>
<ul>
<li>globalcors：此节点下的配置是为了解决SpringCloud Gateway跨域的问题。</li>
<li>routes：表示一个路由数组，可以在此节点下配置多个路由信息。</li>
<li>id：当前路由的唯一标识。</li>
<li>order：路由的优先级，数字越小表示优先级越高。</li>
<li>predicates：网关断言，也就是路由转发的条件，也是一个数组，可以配置多个路由转发条件。</li>
<li>Path：当客户端请求的路径满足Path的规则时，进行路由转发操作。</li>
<li>filters：网关过滤器，在过滤器中可以修改请求的参数和header信息，以及响应的结果和header信息，网关过滤器也是一个数组，可以配置多个过滤规则。</li>
<li>StripPrefix：网关在进行路由转发之前，会去掉1层访问路径。</li>
</ul>
<p>（3）在服务网关shop-gateway模块的<code>io.binghe.shop</code>包下新建GatewayStarter类，表示服务网关的启动类，源码如下所示。</p>
<pre><code class="language-java">/**
 * @version 1.0.0
 * @description 服务网关启动类
 */
@SpringBootApplication
public class GatewayStarter {
    public static void main(String[] args){
        SpringApplication.run(GatewayStarter.class, args);
    }
}
</code></pre>
<p>（4）由于之前项目中整合了Nacos和Sentinel，所以，在启动项目前，要分别启动Nacos和Sentinel。</p>
<ul>
<li>进入到Nacos的bin目录下，输入如下命令启动Nacos。</li>
</ul>
<pre><code class="language-java">startup.cmd -m standalone
</code></pre>
<ul>
<li>进入Sentinel Jar包所在的目录，输入如下命令启动Sentinel。</li>
</ul>
<pre><code class="language-java">java -Dserver.port=8888 -Dcsp.sentinel.dashboard.server=localhost:8888 -Dproject.name=sentinel-dashboard -jar sentinel-dashboard-1.8.4.jar
</code></pre>
<p>（5）分别启动用户微服务、商品微服务、订单微服务和服务网关。</p>
<p>（6）通过服务网关访问用户微服务，在浏览器中输入<code>http://localhost:10001/server-user/user/get/1001</code>，如下所示。</p>
<figure data-type="image" tabindex="3"><img src="https://tinaxiawuhao.github.io/post-images/1658668418813.png" alt="" loading="lazy"></figure>
<p>用户微服务返回的原始数据如下所示。</p>
<pre><code class="language-java">{
  &quot;id&quot;: 1001,
  &quot;username&quot;: &quot;binghe&quot;,
  &quot;password&quot;: &quot;c26be8aaf53b15054896983b43eb6a65&quot;,
  &quot;phone&quot;: &quot;13212345678&quot;,
  &quot;address&quot;: &quot;北京&quot;
}
</code></pre>
<p>可以看到，通过服务网关能够正确访问到用户微服务。</p>
<p>（7）通过服务网关访问商品微服务，在浏览器中输入<code>http://localhost:10001/server-product/product/get/1001</code>，如下所示。</p>
<figure data-type="image" tabindex="4"><img src="https://tinaxiawuhao.github.io/post-images/1658668445345.png" alt="" loading="lazy"></figure>
<p>商品微服务返回的原始数据如下所示。</p>
<pre><code class="language-java">{
  &quot;id&quot;: 1001,
  &quot;proName&quot;: &quot;华为&quot;,
  &quot;proPrice&quot;: 2399,
  &quot;proStock&quot;: 100
}
</code></pre>
<p>可以看到，通过服务网关能够正确访问到商品微服务。</p>
<p>（8）通过服务网关访问订单微服务，在浏览器中输入<code>http://localhost:10001/server-order/order/test_sentinel</code>，如下所示。</p>
<figure data-type="image" tabindex="5"><img src="https://tinaxiawuhao.github.io/post-images/1658668471947.png" alt="" loading="lazy"></figure>
<p>可以看到，通过服务网关能够正确访问到订单微服务。</p>
<h3 id="网关整合nacos">网关整合Nacos</h3>
<p>在初步整合SpringCloud Gateway中，我们在服务网关模块的application.yml文件中硬编码配置了服务转发的地址，如下所示。</p>
<ul>
<li>硬编码用户微服务地址</li>
</ul>
<pre><code class="language-java"> uri: http://localhost:8060
</code></pre>
<ul>
<li>硬编码商品微服务地址</li>
</ul>
<pre><code class="language-java">uri: http://localhost:8070
</code></pre>
<ul>
<li>硬编码订单微服务地址</li>
</ul>
<pre><code class="language-java">uri: http://localhost:8080
</code></pre>
<p>这里，我们将网关整合Nacos实现从Nacos注册中心获取转发的服务地址。</p>
<p>（1）在服务网关shop-gateway模块的pom.xml文件中继续添加如下依赖。</p>
<pre><code class="language-java">&lt;dependency&gt;
    &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>（2）在服务网关shop-gateway模块的启动类<code>io.binghe.shop.GatewayStarter</code>上添加@EnableDiscoveryClient注解，如下所示。</p>
<pre><code class="language-java">/**
 * @version 1.0.0
 * @description 服务网关启动类
 */
@SpringBootApplication
@EnableDiscoveryClient
public class GatewayStarter {
    public static void main(String[] args){
        SpringApplication.run(GatewayStarter.class, args);
    }
}
</code></pre>
<p>（3）将application.yml备份一份，命名为application-simple.yml，并修改application.yml配置文件，修改后的文件如下所示。</p>
<pre><code class="language-java">server:
  port: 10001
spring:
  application:
    name: server-gateway

  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848

    gateway:
      globalcors:
        cors-configurations:
          '[/**]':
            allowedOrigins: &quot;*&quot;
            allowedMethods: &quot;*&quot;
            allowCredentials: true
            allowedHeaders: &quot;*&quot;
      discovery:
        locator:
          enabled: true

      routes:
        - id: user-gateway
          uri: lb://server-user
          order: 1
          predicates:
            - Path=/server-user/**
          filters:
            - StripPrefix=1

        - id: product-gateway
          uri: lb://server-product
          order: 1
          predicates:
            - Path=/server-product/**
          filters:
            - StripPrefix=1

        - id: order-gateway
          uri: lb://server-order
          order: 1
          predicates:
            - Path=/server-order/**
          filters:
            - StripPrefix=1
</code></pre>
<p>上述配置中增加了Nacos相关的配置，如下所示。</p>
<pre><code class="language-java">spring:
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
</code></pre>
<p>新增了让SpringCloud Gateway可以发现Nacos中的服务配置，如下所示。</p>
<pre><code class="language-java">Spring:
  cloud:
    gateway:
      discovery:
        locator:
          enabled: true
</code></pre>
<p>另外，将硬编码的服务转发地址修改成从Nacos中按照名称获取微服务地址，并按照负载均衡策略分发。</p>
<ul>
<li>从Nacos中获取用户微服务</li>
</ul>
<pre><code class="language-java">uri: lb://server-user
</code></pre>
<ul>
<li>从Nacos中获取商品微服务</li>
</ul>
<pre><code class="language-java">uri: lb://server-product
</code></pre>
<ul>
<li>从Nacos中获取订单微服务</li>
</ul>
<pre><code class="language-java">uri: lb://server-order
</code></pre>
<p>其中，lb指的是从Nacos中按照微服务的名称获取微服务地址，并按照负载均衡的策略分发。使用lb从Nacos中获取微服务时，遵循如下的格式。</p>
<pre><code class="language-java">lb://微服务名称
</code></pre>
<p>微服务的名称就是各个微服务在application.yml文件中配置的服务名称。</p>
<pre><code class="language-java">spring:
  application:
    name: 服务名称
</code></pre>
<p>（4）分别启动用户微服务、商品微服务、订单微服务和服务网关。</p>
<p>（5）通过服务网关访问用户微服务，在浏览器中输入<code>http://localhost:10001/server-user/user/get/1001</code>，如下所示。</p>
<figure data-type="image" tabindex="6"><img src="https://tinaxiawuhao.github.io/post-images/1658668500284.png" alt="" loading="lazy"></figure>
<p>用户微服务返回的原始数据如下所示。</p>
<pre><code class="language-java">{
  &quot;id&quot;: 1001,
  &quot;username&quot;: &quot;binghe&quot;,
  &quot;password&quot;: &quot;c26be8aaf53b15054896983b43eb6a65&quot;,
  &quot;phone&quot;: &quot;13212345678&quot;,
  &quot;address&quot;: &quot;北京&quot;
}
</code></pre>
<p>可以看到，通过服务网关能够正确访问到用户微服务。</p>
<p>（6）通过服务网关访问商品微服务，在浏览器中输入<code>http://localhost:10001/server-product/product/get/1001</code>，如下所示。</p>
<figure data-type="image" tabindex="7"><img src="https://tinaxiawuhao.github.io/post-images/1658668536499.png" alt="" loading="lazy"></figure>
<p>商品微服务返回的原始数据如下所示。</p>
<pre><code class="language-java">{
  &quot;id&quot;: 1001,
  &quot;proName&quot;: &quot;华为&quot;,
  &quot;proPrice&quot;: 2399,
  &quot;proStock&quot;: 100
}
</code></pre>
<p>可以看到，通过服务网关能够正确访问到商品微服务。</p>
<p>（7）通过服务网关访问订单微服务，在浏览器中输入<code>http://localhost:10001/server-order/order/test_sentinel</code>，如下所示。</p>
<figure data-type="image" tabindex="8"><img src="https://tinaxiawuhao.github.io/post-images/1658668556502.png" alt="" loading="lazy"></figure>
<p>可以看到，通过服务网关能够正确访问到订单微服务。</p>
<h3 id="网关整合nacos最简配置">网关整合Nacos最简配置</h3>
<p>SpringCloud Gateway整合Nacos后，可以不用手动指定其他微服务的名称来从Nacos中获取微服务的地址。接下来，我们就来实现SpringCloud Gateway网关整合Nacos的最简配置。</p>
<p>（1）将application.yml备份一份，命名为application-nacos.yml，并修改application.yml配置文件，修改后的文件如下所示。</p>
<pre><code class="language-java">server:
  port: 10001
spring:
  application:
    name: server-gateway

  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848

    gateway:
      globalcors:
        cors-configurations:
          '[/**]':
            allowedOrigins: &quot;*&quot;
            allowedMethods: &quot;*&quot;
            allowCredentials: true
            allowedHeaders: &quot;*&quot;
      discovery:
        locator:
          enabled: true
</code></pre>
<p>可以看到，在application.yml文件中，去掉了<code>spring.cloud.gateway.routes</code> 节点及其下面的所有配置。</p>
<p>（2）分别启动用户微服务、商品微服务、订单微服务和服务网关。</p>
<p>（3）通过服务网关访问用户微服务，在浏览器中输入<code>http://localhost:10001/server-user/user/get/1001</code>，如下所示。</p>
<figure data-type="image" tabindex="9"><img src="https://tinaxiawuhao.github.io/post-images/1658668577780.png" alt="" loading="lazy"></figure>
<p>用户微服务返回的原始数据如下所示。</p>
<pre><code class="language-java">{
  &quot;id&quot;: 1001,
  &quot;username&quot;: &quot;binghe&quot;,
  &quot;password&quot;: &quot;c26be8aaf53b15054896983b43eb6a65&quot;,
  &quot;phone&quot;: &quot;13212345678&quot;,
  &quot;address&quot;: &quot;北京&quot;
}
</code></pre>
<p>可以看到，通过服务网关能够正确访问到用户微服务。</p>
<p>（4）通过服务网关访问商品微服务，在浏览器中输入<code>http://localhost:10001/server-product/product/get/1001</code>，如下所示。</p>
<figure data-type="image" tabindex="10"><img src="https://tinaxiawuhao.github.io/post-images/1658668595804.png" alt="" loading="lazy"></figure>
<p>商品微服务返回的原始数据如下所示。</p>
<pre><code class="language-java">{
  &quot;id&quot;: 1001,
  &quot;proName&quot;: &quot;华为&quot;,
  &quot;proPrice&quot;: 2399,
  &quot;proStock&quot;: 100
}
</code></pre>
<p>可以看到，通过服务网关能够正确访问到商品微服务。</p>
<p>（5）通过服务网关访问订单微服务，在浏览器中输入<code>http://localhost:10001/server-order/order/test_sentinel</code>，如下所示。</p>
<figure data-type="image" tabindex="11"><img src="https://tinaxiawuhao.github.io/post-images/1658668615921.png" alt="" loading="lazy"></figure>
<p>可以看到，通过服务网关能够正确访问到订单微服务。</p>
<p><strong>注意：SpringCloud Gateway整合Nacos最简配置时，通过网关访问微服务的格式如下所示。</strong></p>
<pre><code class="language-java">http(s)://网关IP:网关端口/访问的目标微服务名称/接口地址
</code></pre>
<h2 id="网关整合sentinel限流">网关整合Sentinel限流</h2>
<p>Sentinel从1.6.0版本开始，提供了SpringCloud Gateway的适配模块，并且可以提供两种资源维度的限流，一种是route维度；另一种是自定义API分组维度。</p>
<ul>
<li>route维度：对application.yml文件中配置的<code>spring.cloud.gateway.routes.id</code>限流，并且资源名为<code>spring.cloud.gateway.routes.id</code>对应的值。</li>
<li>自定义API分组维度：利用Sentinel提供的API接口来自定义API分组，并且对这些API分组进行限流。</li>
</ul>
<h3 id="实现route维度限流">实现route维度限流</h3>
<p>（1）在服务网关shop-gateway模块的pom.xml文件中添加如下依赖。</p>
<pre><code class="language-java">&lt;dependencies&gt;
    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-alibaba-sentinel&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-alibaba-sentinel-gateway&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-gateway&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.cloud&lt;/groupId&gt;
        &lt;artifactId&gt;spring-cloud-starter-alibaba-nacos-discovery&lt;/artifactId&gt;
    &lt;/dependency&gt;

    &lt;dependency&gt;
        &lt;groupId&gt;com.alibaba.csp&lt;/groupId&gt;
        &lt;artifactId&gt;sentinel-spring-cloud-gateway-adapter&lt;/artifactId&gt;
    &lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>（2）在服务网关shop-gateway模块中新建<code>io.binghe.shop.config</code>包，并在包下新建GatewayConfig类。基于Sentinel 的Gateway限流是通过其提供的Filter来完成的，使用时只需注入对应的SentinelGatewayFilter实例以及 SentinelGatewayBlockExceptionHandler 实例即可。</p>
<p>GatewayConfig类的源代码如下所示。</p>
<pre><code class="language-java">/**
 * @version 1.0.0
 * @description 网关配置类
 */
@Configuration
public class GatewayConfig {

    private final List&lt;ViewResolver&gt; viewResolvers;

    private final ServerCodecConfigurer serverCodecConfigurer;

    @Value(&quot;${spring.cloud.gateway.discovery.locator.route-id-prefix}&quot;)
    private String routeIdPrefix;

    public GatewayConfig(ObjectProvider&lt;List&lt;ViewResolver&gt;&gt; viewResolversProvider,
                                ServerCodecConfigurer serverCodecConfigurer) {
        this.viewResolvers = viewResolversProvider.getIfAvailable(Collections::emptyList);
        this.serverCodecConfigurer = serverCodecConfigurer;
    }

    /**
     * 初始化一个限流的过滤器
     */
    @Bean
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public GlobalFilter sentinelGatewayFilter() {
        return new SentinelGatewayFilter();
    }

    @PostConstruct
    public void init() {
       this.initGatewayRules();
       this.initBlockHandlers();
    }

    /**
     * 配置初始化的限流参数
     */
    private void initGatewayRules() {
        Set&lt;GatewayFlowRule&gt; rules = new HashSet&lt;&gt;();

        /**
         * Sentinel整合SpringCloud Gateway使用的API类型为Route ID类型，也就是基于route维度时，
         * 由于Sentinel为SpringCloud Gateway网关生成的API名称规则如下：
         * 生成的规则为：${spring.cloud.gateway.discovery.locator.route-id-prefix}后面直接加上目标微服务的名称，如下所示。
         * ${spring.cloud.gateway.discovery.locator.route-id-prefix}目标微服务的名称
         * 其中，${spring.cloud.gateway.discovery.locator.route-id-prefix}是在yml文件中配置的访问前缀
         *
         * 为了让通过服务网关访问目标微服务链接后，请求链路中生成的API名称与流控规则中生成的API名称一致，以达到启动项目即可实现访问链接的限流效果，
         * 而无需登录Setinel管理界面手动配置限流规则，可以将
         * resource参数设置为${spring.cloud.gateway.discovery.locator.route-id-prefix}目标微服务的名称
         *
         * 当然，如果不按照上述配置，也可以在项目启动后，通过服务网关访问目标微服务链接后，在Sentinel管理界面的请求链路中找到对应的API名称所代表的请求链路，
         * 然后手动配置限流规则。
         **/
//        //用户微服务网关
//        rules.add(this.getGatewayFlowRule(&quot;user-gateway&quot;));
//        //商品微服务网关
//        rules.add(this.getGatewayFlowRule(&quot;product-gateway&quot;));
//        //订单微服务网关
//        rules.add(this.getGatewayFlowRule(&quot;order-gateway&quot;));
        //用户微服务网关
        rules.add(this.getGatewayFlowRule(getResource(&quot;server-user&quot;)));
        //商品微服务网关
        rules.add(this.getGatewayFlowRule(getResource(&quot;server-product&quot;)));
        //订单微服务网关
        rules.add(this.getGatewayFlowRule(getResource(&quot;server-order&quot;)));
        //加载规则
        GatewayRuleManager.loadRules(rules);
    }

    private String getResource(String targetServiceName){
        if (routeIdPrefix == null){
            routeIdPrefix = &quot;&quot;;
        }
        return routeIdPrefix.concat(targetServiceName);
    }

    private GatewayFlowRule getGatewayFlowRule(String resource){
        //传入资源名称生成GatewayFlowRule
        GatewayFlowRule gatewayFlowRule = new GatewayFlowRule(resource);
        //限流阈值
        gatewayFlowRule.setCount(1);
        //统计的时间窗口，单位为
        gatewayFlowRule.setIntervalSec(1);
        return gatewayFlowRule;
    }

    /**
     * 配置限流的异常处理器
     */
    @Bean
    @Order(Ordered.HIGHEST_PRECEDENCE)
    public SentinelGatewayBlockExceptionHandler sentinelGatewayBlockExceptionHandler() {
        return new SentinelGatewayBlockExceptionHandler(viewResolvers, serverCodecConfigurer);
    }

    /**
     * 自定义限流异常页面
     */
    private void initBlockHandlers() {
        BlockRequestHandler blockRequestHandler = new BlockRequestHandler() {
            @Override
            public Mono&lt;ServerResponse&gt; handleRequest(ServerWebExchange serverWebExchange, Throwable throwable) {
                Map map = new HashMap&lt;&gt;();
                map.put(&quot;code&quot;, 1001);
                map.put(&quot;codeMsg&quot;, &quot;接口被限流了&quot;);
                return ServerResponse.status(HttpStatus.OK).
                        contentType(MediaType.APPLICATION_JSON_UTF8).
                        body(BodyInserters.fromObject(map));
            }
        };
        GatewayCallbackManager.setBlockHandler(blockRequestHandler);
    }
}
</code></pre>
<p>GatewayConfig类的源代码看上去比较多，但是都是一些非常简单的方法，冰河在这里就不再赘述了。</p>
<p><strong>这里有个需要特别注意的地方：</strong></p>
<p><strong>Sentinel1.8.4整合SpringCloud Gateway使用的API类型为Route ID类型时，也就是基于route维度时，由于Sentinel为SpringCloud Gateway网关生成的API名称规则如下：</strong></p>
<p><strong>生成的规则为：****${spring.cloud.gateway.discovery.locator.route-id-prefix}后面直接加上目标微服务的名称，如下所示。</strong></p>
<p><strong>{spring.cloud.gateway.discovery.locator.route-id-prefix}目标微服务的名称。其中，${spring.cloud.gateway.discovery.locator.route-id-prefix}是在yml文件中配置的访问前缀。</strong></p>
<p><strong>为了让通过服务网关访问目标微服务链接后，请求链路中生成的API名称与流控规则中生成的API名称一致，以达到启动项目即可实现访问链接的限流效果，而无需登录Setinel管理界面手动配置限流规则，可以将生成GatewayFlowRule对象的resource参数设置为${spring.cloud.gateway.discovery.locator.route-id-prefix}目标微服务的名称</strong></p>
<p><strong>当然，如果不按照上述配置，也可以在项目启动后，通过服务网关访问目标微服务链接后，在Sentinel管理界面的请求链路中找到对应的API名称所代表的请求链路，然后手动配置限流规则。</strong></p>
<p>（3）将服务网关shop-gateway模块的application.yml文件备份一份名称为application-nacos-simple.yml的文件，并将application.yml文件的内容修改成如下所示。</p>
<pre><code class="language-java">server:
  port: 10001
spring:
  application:
    name: server-gateway
  main:
    allow-bean-definition-overriding: true
  cloud:
    nacos:
      discovery:
        server-addr: 127.0.0.1:8848
    sentinel:
      transport:
        port: 7777
        dashboard: 127.0.0.1:8888
      web-context-unify: false
      eager: true
      
    gateway:
      globalcors:
        cors-configurations:
          '[/**]':
            allowedOrigins: &quot;*&quot;
            allowedMethods: &quot;*&quot;
            allowCredentials: true
            allowedHeaders: &quot;*&quot;
      discovery:
        locator:
          enabled: true
          route-id-prefix: gateway-
</code></pre>
<p>其中：</p>
<ul>
<li><code>spring.cloud.sentinel.eager</code>表示程序启动时，流控规则是否立即注册到Sentinel，配置为true表示立即注册到Sentinel。</li>
<li><code>spring.cloud.gateway.discovery.locator.route-id-prefix</code>：生成流控规则API名称的前缀。</li>
</ul>
<p>（4）在IDEA中配置启动服务网关shop-gateway模块的参数<code>-Dcsp.sentinel.app.type=1</code>，如下所示。</p>
<p><img src="https://tinaxiawuhao.github.io/post-images/1658668642858.png" alt="" loading="lazy"><br>
如果是在命令行启动网关服务的Jar包，则可以使用如下命令。</p>
<pre><code class="language-java">java -Dcsp.sentinel.app.type=1 shop-gateway.jar
</code></pre>
<p>或者在启动类<code>io.binghe.shop.GatewayStarter</code>的main()方法中添加一行<code>System.setProperty(&quot;csp.sentinel.app.type&quot;, &quot;1&quot;);</code>代码，如下所示。</p>
<pre><code class="language-java">/**
 * @version 1.0.0
 * @description 服务网关启动类
 */
@SpringBootApplication
@EnableDiscoveryClient
public class GatewayStarter {
    public static void main(String[] args){
        System.setProperty(&quot;csp.sentinel.app.type&quot;, &quot;1&quot;);
        SpringApplication.run(GatewayStarter.class, args);
    }
}
</code></pre>
<p>（5）分别启动用户微服务、商品微服务、订单微服务和服务网关，启动后会在Sentinel管理界面左侧菜单栏中看到server-gateway菜单，如下所示。</p>
<figure data-type="image" tabindex="12"><img src="https://tinaxiawuhao.github.io/post-images/1658668665072.png" alt="" loading="lazy"></figure>
<p>在server-gateway菜单下的流控规则子菜单中可以看到网关的流控规则已经注册到Sentinel，如下所示。</p>
<figure data-type="image" tabindex="13"><img src="https://tinaxiawuhao.github.io/post-images/1658668680016.png" alt="" loading="lazy"></figure>
<p>（6）通过服务网关访问用户微服务，在浏览器中输入<code>http://localhost:10001/server-user/user/get/1001</code>，不断刷新页面，如下所示。</p>
<figure data-type="image" tabindex="14"><img src="https://tinaxiawuhao.github.io/post-images/1658668691646.png" alt="" loading="lazy"></figure>
<p>用户微服务返回的原始数据如下所示。</p>
<pre><code class="language-java">{
  &quot;code&quot;: 1001,
  &quot;codeMsg&quot;: &quot;接口被限流了&quot;
}
</code></pre>
<p>可以看到，通过服务网关不断刷新用户微服务时，触发了服务限流，并返回了自定义的限流结果数据。</p>
<p>（7）通过服务网关访问商品微服务，在浏览器中输入<code>http://localhost:10001/server-product/product/get/1001</code>，不断刷新页面，如下所示。</p>
<figure data-type="image" tabindex="15"><img src="https://tinaxiawuhao.github.io/post-images/1658668707383.png" alt="" loading="lazy"></figure>
<p>商品微服务返回的原始数据如下所示。</p>
<pre><code class="language-java">{
  &quot;code&quot;: 1001,
  &quot;codeMsg&quot;: &quot;接口被限流了&quot;
}
</code></pre>
<p>可以看到，通过服务网关不断刷新商品微服务时，触发了服务限流，并返回了自定义的限流结果数据。</p>
<p>（8）通过服务网关访问订单微服务，在浏览器中输入<code>http://localhost:10001/server-order/order/test_sentinel</code>，不断刷新页面，如下所示。</p>
<figure data-type="image" tabindex="16"><img src="https://tinaxiawuhao.github.io/post-images/1658668723929.png" alt="" loading="lazy"></figure>
<p>可以看到，通过服务网关不断刷新订单微服务时，触发了服务限流，并返回了自定义的限流结果数据。</p>
<h3 id="实现自定义api分组维度限流">实现自定义API分组维度限流</h3>
<p>前面，我们实现了route维度的限流，接下来，我们再基于Sentinel与SpringCloud gateway实现自定义API分组维度的限流。</p>
<p>（1）在服务网关shop-gateway模块的<code>io.binghe.shop.config.GatewayConfig</code>配置类中新增initCustomizedApis()方法，初始化API管理的信息，源码如下所示。</p>
<pre><code class="language-java">private void initCustomizedApis() {
    Set&lt;ApiDefinition&gt; definitions = new HashSet&lt;&gt;();
    ApiDefinition api1 = new ApiDefinition(&quot;user_api1&quot;)
        .setPredicateItems(new HashSet&lt;ApiPredicateItem&gt;() {{
            // 以/server-user/user/api1 开头的请求
            add(new ApiPathPredicateItem().setPattern(&quot;/server-user/user/api1/**&quot;).
                setMatchStrategy(SentinelGatewayConstants.URL_MATCH_STRATEGY_PREFIX));
        }});
    ApiDefinition api2 = new ApiDefinition(&quot;user_api2&quot;)
        .setPredicateItems(new HashSet&lt;ApiPredicateItem&gt;() {{
            // 以/server-user/user/api2/demo1 完成的url路径匹配
            add(new ApiPathPredicateItem().setPattern(&quot;/server-user/user/api2/demo1&quot;));
        }});
    definitions.add(api1);
    definitions.add(api2);
    GatewayApiDefinitionManager.loadApiDefinitions(definitions);
}
</code></pre>
<p>上述代码中，配置了两个API分组，每个API分组的规则如下。</p>
<ul>
<li>user_api1分组：匹配以<code>/product-serv/product/api1</code>开头的所有请求。</li>
<li>user_api2分组：精确匹配<code>/server-user/user/api2/demo1</code>。</li>
</ul>
<p>（2）在服务网关shop-gateway模块的<code>io.binghe.shop.config.GatewayConfig</code>配置类中init()方法中调用initCustomizedApis()方法，为了避免route维度的限流对自定义API分组维度的限流产生影响，这里，同时在init()方法中注释掉调用initGatewayRules()方法，修改后的init()方法的代码如下所示。</p>
<pre><code class="language-java">@PostConstruct
public void init() {
    //this.initGatewayRules();
    this.initBlockHandlers();
    this.initCustomizedApis();
}
</code></pre>
<p>（3）在用户微服务shop-user的<code>io.binghe.shop.user.controller.UserController</code>类中新增四个测试接口，源码如下所示。</p>
<pre><code class="language-java">@GetMapping(value = &quot;/api1/demo1&quot;)
public String api1Demo1(){
    log.info(&quot;访问了api1Demo1接口&quot;);
    return &quot;api1Demo1&quot;;
}
@GetMapping(value = &quot;/api1/demo2&quot;)
public String api1Demo2(){
    log.info(&quot;访问了api1Demo2接口&quot;);
    return &quot;api1Demo2&quot;;
}

@GetMapping(value = &quot;/api2/demo1&quot;)
public String api2Demo1(){
    log.info(&quot;访问了api2Demo1接口&quot;);
    return &quot;api2Demo1&quot;;
}
@GetMapping(value = &quot;/api2/demo2&quot;)
public String api2Demo2(){
    log.info(&quot;访问了api2Demo2接口&quot;);
    return &quot;api2Demo2&quot;;
}
</code></pre>
<p>（4）分别启动用户微服务、商品微服务、订单微服务和服务网关，启动后会在Sentinel管理界面左侧菜单栏中看到server-gateway菜单，如下所示。</p>
<figure data-type="image" tabindex="17"><img src="https://tinaxiawuhao.github.io/post-images/1658668748563.png" alt="" loading="lazy"></figure>
<p>此时，由于我们注释了调用以route维度限流的方法，所以，在流控规则里的限流规则为空，如下所示。</p>
<figure data-type="image" tabindex="18"><img src="https://tinaxiawuhao.github.io/post-images/1658668764215.png" alt="" loading="lazy"></figure>
<p>在API管理里面会发现我们定义的API分组已经自动注册到Sentinel中了，如下所示。</p>
<figure data-type="image" tabindex="19"><img src="https://tinaxiawuhao.github.io/post-images/1658668773447.png" alt="" loading="lazy"></figure>
<p>（5）在Sentinel管理界面的流控规则中，新增网关流控规则，如下所示。</p>
<figure data-type="image" tabindex="20"><img src="https://tinaxiawuhao.github.io/post-images/1658668783657.png" alt="" loading="lazy"></figure>
<p>点击新增网关流控规则后，会弹出新增网关流控规则配置框，按照如下方式为user_api1分组配置限流规则。</p>
<figure data-type="image" tabindex="21"><img src="https://tinaxiawuhao.github.io/post-images/1658668798808.png" alt="" loading="lazy"></figure>
<p>点击新增按钮后，按照同样的方式为user_api2分组配置限流规则。</p>
<figure data-type="image" tabindex="22"><img src="https://tinaxiawuhao.github.io/post-images/1658668819062.png" alt="" loading="lazy"></figure>
<p>配置完毕后，在流控规则中的限流规则如下所示。</p>
<figure data-type="image" tabindex="23"><img src="https://tinaxiawuhao.github.io/post-images/1658668856618.png" alt="" loading="lazy"></figure>
<p>（6）预期的测试结果如下。</p>
<ul>
<li>当频繁访问<code>http://localhost:10001/server-user/user/api1/demo1</code>时会被限流。</li>
<li>当频繁访问<code>http://localhost:10001/server-user/user/api1/demo2</code>时会被限流。</li>
<li>当频繁访问<code>http://localhost:10001/server-user/user/api2/demo1</code>时会被限流。</li>
<li>当频繁访问<code>http://localhost:10001/server-user/user/api2/demo2</code>时不会被限流。</li>
</ul>
<p><strong>注意：只有最后一个不会被限流。</strong></p>
<p>（7）在浏览器上频繁访问<code>http://localhost:10001/server-user/user/api1/demo1</code>，如下所示。</p>
<figure data-type="image" tabindex="24"><img src="https://tinaxiawuhao.github.io/post-images/1658668864366.png" alt="" loading="lazy"></figure>
<p>返回的原始数据如下所示。</p>
<pre><code class="language-java">{
  &quot;code&quot;: 1001,
  &quot;codeMsg&quot;: &quot;接口被限流了&quot;
}
</code></pre>
<p>说明触发了服务限流，并返回了自定义的限流结果数据。</p>
<p>（8）在浏览器上频繁访问<code>http://localhost:10001/server-user/user/api1/demo2</code>，如下所示。</p>
<figure data-type="image" tabindex="25"><img src="https://tinaxiawuhao.github.io/post-images/1658668872082.png" alt="" loading="lazy"></figure>
<p>返回的原始数据如下所示。</p>
<pre><code class="language-java">{
  &quot;code&quot;: 1001,
  &quot;codeMsg&quot;: &quot;接口被限流了&quot;
}
</code></pre>
<p>说明触发了服务限流，并返回了自定义的限流结果数据。</p>
<p>（9）在浏览器上频繁访问<code>http://localhost:10001/server-user/user/api2/demo1</code>，如下所示。</p>
<figure data-type="image" tabindex="26"><img src="https://tinaxiawuhao.github.io/post-images/1658668880990.png" alt="" loading="lazy"></figure>
<p>返回的原始数据如下所示。</p>
<pre><code class="language-java">{
  &quot;code&quot;: 1001,
  &quot;codeMsg&quot;: &quot;接口被限流了&quot;
}
</code></pre>
<p>说明触发了服务限流，并返回了自定义的限流结果数据。</p>
<p>（10）在浏览器上频繁访问<code>http://localhost:10001/server-user/user/api2/demo2</code>，如下所示。</p>
<figure data-type="image" tabindex="27"><img src="https://tinaxiawuhao.github.io/post-images/1658668890430.png" alt="" loading="lazy"></figure>
<p>可以看到，访问<code>http://localhost:10001/server-user/user/api2/demo2</code>时，无论访问的频率多频繁，都不会触发Sentinel限流。</p>
<p>至此，我们就成功在项目中整合了SpringCloud Gateway网关，并通过Sentinel整合SpringCloud Gateway实现了网关的限流操作。</p>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E9%A1%B9%E7%9B%AE%E6%95%B4%E5%90%88%E7%BD%91%E5%85%B3">项目整合网关</a>
<ul>
<li><a href="#%E6%96%B0%E5%BB%BA%E7%BD%91%E5%85%B3%E6%A8%A1%E5%9D%97">新建网关模块</a></li>
<li><a href="#%E5%88%9D%E6%AD%A5%E6%95%B4%E5%90%88springcloud-gateway">初步整合SpringCloud Gateway</a></li>
<li><a href="#%E7%BD%91%E5%85%B3%E6%95%B4%E5%90%88nacos">网关整合Nacos</a></li>
<li><a href="#%E7%BD%91%E5%85%B3%E6%95%B4%E5%90%88nacos%E6%9C%80%E7%AE%80%E9%85%8D%E7%BD%AE">网关整合Nacos最简配置</a></li>
</ul>
</li>
<li><a href="#%E7%BD%91%E5%85%B3%E6%95%B4%E5%90%88sentinel%E9%99%90%E6%B5%81">网关整合Sentinel限流</a>
<ul>
<li><a href="#%E5%AE%9E%E7%8E%B0route%E7%BB%B4%E5%BA%A6%E9%99%90%E6%B5%81">实现route维度限流</a></li>
<li><a href="#%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%AE%9A%E4%B9%89api%E5%88%86%E7%BB%84%E7%BB%B4%E5%BA%A6%E9%99%90%E6%B5%81">实现自定义API分组维度限流</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          
              <hr />
            
          
            
            <p class="next-post">上一篇：
                <a href="https://tinaxiawuhao.github.io/post/8Wk_K0cjl/">
                  <span class="post-title">
                    gateway网关概述&rarr;
                  </span>
                </a>
              </p>
            
          
            
           <p class="prev-post">下一篇：
                 <a href="https://tinaxiawuhao.github.io/post/ipsD-XbrM/">
                   <span class="post-title">
                     网关断言&rarr;
                   </span>
                 </a>
               </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
            <li class="list-inline-item">
              <a href="https://github.com/tinaxiawuhao" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://tinaxiawuhao.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>tianxia</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://tinaxiawuhao.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://tinaxiawuhao.github.io/media/scripts/clean-blog.min.js"></script> -->
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <div id="landlord-parent">
    <div id="landlord">
        <div class="message" style="opacity:0"></div>
        <canvas id="live2d" width="240" height="250" class="live2d"></canvas>
    </div>
</div>

<script type="text/javascript">
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)) {
        //移动端
        console.log("------ 移动端");
    } else {
        console.log("------ PC端 " + navigator.userAgent);

        addScript("https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/js/live2d.js", () => {
            // 加载完成后再loadlive2d
            loadlive2d("live2d", "https://tinaxiawuhao.github.io/media/live2d/assets/tororo.model.json");
        });

        var home_Path = "https://tinaxiawuhao.github.io/";
        addScript("https://tinaxiawuhao.github.io/media/live2d/js/message.js", () => { });
    }

    // 插入js文件，完成后callback
    function addScript(jsfile, callback) {
        var landlord_parent = document.getElementById("landlord-parent");
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = jsfile;
        landlord_parent.appendChild(script);
        script.onload = script.onreadystatechange = function () {
            if (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") {
                script.onload = script.onreadystatechange = null;
                if (callback && typeof callback == "function") {
                    callback(); //window[callback]();如果传递字符串过来 调用window['函数名']() 调用方法
                }
            }
        };
    }
</script>
  
  <script src="https://tinaxiawuhao.github.io/media/scripts/tocScript.js"></script>
</body>

</html>
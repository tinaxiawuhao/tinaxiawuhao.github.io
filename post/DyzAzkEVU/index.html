<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[tianxia]的个人博客">
<meta name="author" content="kveln">
<title>消息队列选型 | tianxia</title>
<link rel="stylesheet" href="https://tinaxiawuhao.github.io/resource/bootstrap.min.css">
<link href="https://tinaxiawuhao.github.io/resource/all.min.css" rel="stylesheet">
<link rel="alternate" type="application/rss+xml" title="消息队列选型 | tianxia » Feed"
  href="https://tinaxiawuhao.github.io/atom.xml">
<link rel="stylesheet"
  href="https://tinaxiawuhao.github.io/resource/androidstudio.min.css">
<link href="https://tinaxiawuhao.github.io/styles/main.css" rel="stylesheet">
<script src="https://tinaxiawuhao.github.io/resource/jquery.min.js"></script>

<script src="https://tinaxiawuhao.github.io/resource/highlight.min.js"></script>

<link rel="stylesheet" href="https://tinaxiawuhao.github.io/resource/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="消息队列选型" />
  <meta property="og:url" content="https://tinaxiawuhao.github.io/post/DyzAzkEVU/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="tianxia" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tinaxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1663068709855"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tinaxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1663068709855"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://tinaxiawuhao.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://tinaxiawuhao.github.io/tag/3MF0KR5FN/" class="tag">MQ</a>
                
              </span>
              <h1>消息队列选型</h1>
              <span class="meta">
                Posted on
                2022-03-15，14 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <img class="post-feature-header-image" src="https://tinaxiawuhao.github.io/post-images/DyzAzkEVU.png" alt="封面图">
          </img>
          
          <h3 id="消息队列">消息队列</h3>
<p>常用的消息队列主要这 4 种，分别为 Kafka、RabbitMQ、RocketMQ 和 ActiveMQ，主要介绍前三，不BB，上思维导图！</p>
<figure data-type="image" tabindex="1"><img src="https://tinaxiawuhao.github.io/post-images/1657627504417.png" alt="" loading="lazy"></figure>
<h3 id="消息队列基础">消息队列基础</h3>
<h4 id="什么是消息队列">什么是消息队列？</h4>
<p>消息队列是在消息的传输过程中保存消息的容器，用于接收消息并以文件的方式存储，一个消息队列可以被一个也可以被多个消费者消费，包含以下 3 元素：</p>
<ul>
<li>Producer：消息生产者，负责产生和发送消息到 Broker；</li>
<li>Broker：消息处理中心，负责消息存储、确认、重试等，一般其中会包含多个 Queue；</li>
<li>Consumer：消息消费者，负责从 Broker 中获取消息，并进行相应处理。</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://tinaxiawuhao.github.io/post-images/1657627512680.png" alt="" loading="lazy"></figure>
<h4 id="消息队列模式">消息队列模式</h4>
<ul>
<li>点对点模式：多个生产者可以向同一个消息队列发送消息，一个具体的消息只能由一个消费者消费。</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://tinaxiawuhao.github.io/post-images/1657627520099.png" alt="" loading="lazy"></figure>
<ul>
<li>发布/订阅模式：单个消息可以被多个订阅者并发的获取和处理。</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://tinaxiawuhao.github.io/post-images/1657627527080.png" alt="" loading="lazy"></figure>
<h4 id="消息队列应用场景">消息队列应用场景</h4>
<ul>
<li><strong>应用解耦</strong>：消息队列减少了服务之间的耦合性，不同的服务可以通过消息队列进行通信，而不用关心彼此的实现细节。</li>
<li><strong>异步处理</strong>：消息队列本身是异步的，它允许接收者在消息发送很长时间后再取回消息。</li>
<li><strong>流量削锋</strong>：当上下游系统处理能力存在差距的时候，利用消息队列做一个通用的”载体”，在下游有能力处理的时候，再进行分发与处理。</li>
<li><strong>日志处理</strong>：日志处理是指将消息队列用在日志处理中，比如 Kafka 的应用，解决大量日志传输的问题。</li>
<li><strong>消息通讯</strong>：消息队列一般都内置了高效的通信机制，因此也可以用在纯的消息通讯，比如实现点对点消息队列，或者聊天室等。</li>
<li><strong>消息广播</strong>：如果没有消息队列，每当一个新的业务方接入，我们都要接入一次新接口。有了消息队列，我们只需要关心消息是否送达了队列，至于谁希望订阅，是下游的事情，无疑极大地减少了开发和联调的工作量。</li>
</ul>
<h3 id="常用消息队列">常用消息队列</h3>
<p>由于官方社区现在对 ActiveMQ 5.x 维护越来越少，较少在大规模吞吐的场景中使用，所以我们主要讲解 Kafka、RabbitMQ 和 RocketMQ。</p>
<h4 id="kafka">Kafka</h4>
<p>Apache Kafka 最初由 LinkedIn 公司基于独特的设计实现为一个分布式的提交日志系统，之后成为 Apache 项目的一部分，<strong>号称大数据的杀手锏，在数据采集、传输、存储的过程中发挥着举足轻重的作用。</strong></p>
<p><strong>它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台</strong>，它同时也是一款开源的基于发布订阅模式的消息引擎系统。</p>
<h5 id="重要概念">重要概念</h5>
<ul>
<li><strong>主题（Topic）</strong>：消息的种类称为主题，可以说一个主题代表了一类消息，相当于是对消息进行分类，主题就像是数据库中的表。</li>
<li><strong>分区（partition）</strong>：主题可以被分为若干个分区，同一个主题中的分区可以不在一个机器上，有可能会部署在多个机器上，由此来实现 kafka 的伸缩性。</li>
<li><strong>批次</strong>：为了提高效率， 消息会分批次写入 Kafka，批次就代指的是一组消息。</li>
<li><strong>消费者群组（Consumer Group）</strong>：消费者群组指的就是由一个或多个消费者组成的群体。</li>
<li><strong>Broker</strong>: 一个独立的 Kafka 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量，并提交消息到磁盘保存。</li>
<li><strong>Broker 集群</strong>：broker 集群由一个或多个 broker 组成。</li>
<li><strong>重平衡（Rebalance）</strong>：消费者组内某个消费者实例挂掉后，其他消费者实例自动重新分配订阅主题分区的过程。</li>
</ul>
<h5 id="kafka-架构">Kafka 架构</h5>
<p>一个典型的 Kafka 集群中包含 Producer、broker、Consumer Group、Zookeeper 集群。</p>
<p>Kafka 通过 Zookeeper 管理集群配置，选举 leader，以及在 Consumer Group 发生变化时进行 rebalance。Producer 使用 push 模式将消息发布到 broker，Consumer 使用 pull 模式从 broker 订阅并消费消息。</p>
<figure data-type="image" tabindex="5"><img src="https://tinaxiawuhao.github.io/post-images/1657627597961.png" alt="" loading="lazy"></figure>
<h5 id="kafka-工作原理">Kafka 工作原理</h5>
<p>消息经过序列化后，通过不同的分区策略，找到对应的分区。</p>
<p><strong>相同主题和分区的消息，会被存放在同一个批次里</strong>，然后由一个独立的线程负责把它们发到 Kafka Broker 上。</p>
<figure data-type="image" tabindex="6"><img src="https://tinaxiawuhao.github.io/post-images/1657627604741.png" alt="" loading="lazy"></figure>
<p>分区的策略包括顺序轮询、随机轮询和 key hash 这 3 种方式，那什么是分区呢？</p>
<p>分区是 Kafka 读写数据的最小粒度，比如主题 A 有 15 条消息，有 5 个分区，如果采用顺序轮询的方式，15 条消息会顺序分配给这 5 个分区，后续消费的时候，也是按照分区粒度消费。</p>
<figure data-type="image" tabindex="7"><img src="https://tinaxiawuhao.github.io/post-images/1657627611867.png" alt="" loading="lazy"></figure>
<p>由于分区可以部署在多个不同的机器上，所以可以通过分区实现 Kafka 的伸缩性，比如主题 A 的 5 个分区，分别部署在 5 台机器上，如果下线一台，分区就变为 4。</p>
<p>Kafka 消费是通过消费群组完成，同一个消费者群组，<strong>一个消费者可以消费多个分区，但是一个分区，只能被一个消费者消费。</strong></p>
<figure data-type="image" tabindex="8"><img src="https://tinaxiawuhao.github.io/post-images/1657627618721.png" alt="" loading="lazy"></figure>
<p><strong>如果消费者增加，会触发 Rebalance，也就是分区和消费者需要重新配对</strong>。</p>
<p><strong>不同的消费群组互不干涉</strong>，比如下图的 2 个消费群组，可以分别消费这 4 个分区的消息，互不影响。</p>
<figure data-type="image" tabindex="9"><img src="https://tinaxiawuhao.github.io/post-images/1657627625216.png" alt="" loading="lazy"></figure>
<blockquote>
<p>更多知识，详见<a href="https://tinaxiawuhao.github.io/post/KM-0yw6ab/">Kafka 架构深入</a></p>
</blockquote>
<h4 id="rocketmq">RocketMQ</h4>
<p>RocketMQ 是阿里开源的消息中间件，它是纯 Java 开发，<strong>具有高性能、高可靠、高实时、适合大规模分布式系统应用的特点。</strong></p>
<p>RocketMQ 思路起源于 Kafka，但并不是 Kafka 的一个 Copy，<strong>它对消息的可靠传输及事务性做了优化</strong>，目前在阿里集团被广泛应用于交易、充值、流计算、消息推送、日志流式处理、binlog 分发等场景。</p>
<h5 id="重要概念-2">重要概念</h5>
<ul>
<li><strong>Name 服务器（NameServer）</strong>：充当注册中心，类似 Kafka 中的 Zookeeper。</li>
<li><strong>Broker</strong>: 一个独立的 RocketMQ 服务器就被称为 broker，broker 接收来自生产者的消息，为消息设置偏移量。</li>
<li><strong>主题（Topic）</strong>：消息的第一级类型，一条消息必须有一个 Topic。</li>
<li><strong>子主题（Tag）</strong>：消息的第二级类型，同一业务模块不同目的的消息就可以用相同 Topic 和不同的 Tag 来标识。</li>
<li><strong>分组（Group）</strong>：一个组可以订阅多个 Topic，包括生产者组（Producer Group）和消费者组（Consumer Group）。</li>
<li><strong>队列（Queue）</strong>：可以类比 Kafka 的分区 Partition。</li>
</ul>
<h5 id="rocketmq-工作原理">RocketMQ 工作原理</h5>
<p>RockerMQ 中的消息模型就是按照主题模型所实现的，包括 Producer Group、Topic、Consumer Group 三个角色。</p>
<p><strong>为了提高并发能力，一个 Topic 包含多个 Queue</strong>，生产者组根据主题将消息放入对应的 Topic，下图是采用轮询的方式找到里面的 Queue。</p>
<p>RockerMQ 中的消费群组和 Queue，可以类比 Kafka 中的消费群组和 Partition：<strong>不同的消费者组互不干扰，一个 Queue 只能被一个消费者消费，一个消费者可以消费多个 Queue。</strong></p>
<p>消费 Queue 的过程中，通过偏移量记录消费的位置。</p>
<figure data-type="image" tabindex="10"><img src="https://tinaxiawuhao.github.io/post-images/1657627636503.png" alt="" loading="lazy"></figure>
<h5 id="rocketmq-架构">RocketMQ 架构</h5>
<p>RocketMQ 技术架构中有四大角色 NameServer、Broker、Producer 和 Consumer，下面主要介绍 Broker。</p>
<p><strong>Broker 用于存放 Queue，一个 Broker 可以配置多个 Topic，一个 Topic 中存在多个 Queue。</strong></p>
<p>如果某个 Topic 消息量很大，应该给它多配置几个 Queue，并且尽量多分布在不同 broker 上，以减轻某个 broker 的压力。Topic 消息量都比较均匀的情况下，如果某个 broker 上的队列越多，则该 broker 压力越大。</p>
<figure data-type="image" tabindex="11"><img src="https://tinaxiawuhao.github.io/post-images/1657627647064.png" alt="" loading="lazy"></figure>
<p>简单提一下，Broker 通过集群部署，并且提供了 master/slave 的结构，slave 定时从 master 同步数据（同步刷盘或者异步刷盘），如果 master 宕机，则 slave 提供消费服务，但是不能写入消息。</p>
<p>看到这里，大家应该可以发现，RocketMQ 的设计和 Kafka 真的很像！</p>
<blockquote>
<p>更多知识，详见</p>
</blockquote>
<h4 id="rabbitmq">RabbitMQ</h4>
<p>RabbitMQ 2007 年发布，是使用 Erlang 语言开发的开源消息队列系统，基于 AMQP 协议来实现。</p>
<p>AMQP 的主要特征是面向消息、队列、路由、可靠性、安全。<strong>AMQP 协议更多用在企业系统内，对数据一致性、稳定性和可靠性要求很高的场景，对性能和吞吐量的要求还在其次。</strong></p>
<h5 id="重要概念-3">重要概念</h5>
<ul>
<li><strong>信道（Channel）</strong>：消息读写等操作在信道中进行，客户端可以建立多个信道，每个信道代表一个会话任务。</li>
<li><strong>交换器（Exchange）</strong>：接收消息，按照路由规则将消息路由到一个或者多个队列；如果路由不到，或者返回给生产者，或者直接丢弃。</li>
<li><strong>路由键（RoutingKey）</strong>：生产者将消息发送给交换器的时候，会发送一个 RoutingKey，用来指定路由规则，这样交换器就知道把消息发送到哪个队列。</li>
<li><strong>绑定（Binding）</strong>：交换器和消息队列之间的虚拟连接，绑定中可以包含一个或者多个 RoutingKey。</li>
</ul>
<h5 id="rabbitmq-工作原理">RabbitMQ 工作原理</h5>
<p>AMQP 协议模型由三部分组成：生产者、消费者和服务端，执行流程如下：</p>
<ol>
<li>生产者是连接到 Server，建立一个连接，开启一个信道。</li>
<li>生产者声明交换器和队列，设置相关属性，并通过路由键将交换器和队列进行绑定。</li>
<li>消费者也需要进行建立连接，开启信道等操作，便于接收消息。</li>
<li>生产者发送消息，发送到服务端中的虚拟主机。</li>
<li>虚拟主机中的交换器根据路由键选择路由规则，发送到不同的消息队列中。</li>
<li>订阅了消息队列的消费者就可以获取到消息，进行消费。</li>
</ol>
<figure data-type="image" tabindex="12"><img src="https://tinaxiawuhao.github.io/post-images/1657627658105.png" alt="" loading="lazy"></figure>
<h5 id="常用交换器">常用交换器</h5>
<p>RabbitMQ 常用的交换器类型有 direct、topic、fanout、headers 四种</p>
<p>具体的使用方法，可以参考官网：</p>
<ul>
<li>官网入口：https://www.rabbitmq.com/getstarted.html</li>
</ul>
<figure data-type="image" tabindex="13"><img src="https://tinaxiawuhao.github.io/post-images/1657627665439.png" alt="" loading="lazy"></figure>
<figure data-type="image" tabindex="14"><img src="https://tinaxiawuhao.github.io/post-images/1657627671336.png" alt="" loading="lazy"></figure>
<blockquote>
<p>更多知识，详见</p>
</blockquote>
<h3 id="消息队列对比选型">消息队列对比&amp;选型</h3>
<figure data-type="image" tabindex="15"><img src="https://tinaxiawuhao.github.io/post-images/1657627677983.png" alt="" loading="lazy"></figure>
<h4 id="消息队列对比">消息队列对比</h4>
<h5 id="kafka-2">Kafka</h5>
<p><strong>优点：</strong></p>
<ul>
<li><strong>高吞吐、低延迟</strong>：Kafka 最大的特点就是收发消息非常快，Kafka 每秒可以处理几十万条消息，它的最低延迟只有几毫秒；</li>
<li><strong>高伸缩性</strong>：每个主题（topic）包含多个分区（partition），主题中的分区可以分布在不同的主机（broker）中；</li>
<li><strong>高稳定性</strong>：Kafka 是分布式的，一个数据多个副本，某个节点宕机，Kafka 集群能够正常工作；</li>
<li><strong>持久性、可靠性、可回溯</strong>：Kafka 能够允许数据的持久化存储，消息被持久化到磁盘，并支持数据备份防止数据丢失，支持消息回溯；</li>
<li>消息有序：通过控制能够保证所有消息被消费且仅被消费一次；</li>
<li>有优秀的第三方 Kafka Web 管理界面 Kafka-Manager，在日志领域比较成熟，被多家公司和多个开源项目使用。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>Kafka 单机超过 64 个队列/分区，Load 会发生明显的飙高现象，队列越多，load 越高，发送消息响应时间变长；</li>
<li><strong>不支持消息路由，不支持延迟发送，不支持消息重试；</strong></li>
<li><strong>社区更新较慢。</strong></li>
</ul>
<h5 id="rocketmq-2">RocketMQ</h5>
<p><strong>优点：</strong></p>
<ul>
<li><strong>高吞吐</strong>：借鉴 Kafka 的设计，单一队列百万消息的堆积能力；</li>
<li><strong>高伸缩性</strong>：灵活的分布式横向扩展部署架构，整体架构其实和 kafka 很像；</li>
<li><strong>高容错性</strong>：通过ACK机制，保证消息一定能正常消费；</li>
<li><strong>持久化、可回溯</strong>：消息可以持久化到磁盘中，支持消息回溯；</li>
<li>消息有序：在一个队列中可靠的先进先出（FIFO）和严格的顺序传递；</li>
<li>支持发布/订阅和点对点消息模型，支持拉、推两种消息模式；</li>
<li>提供 docker 镜像用于隔离测试和云集群部署，提供配置、指标和监控等功能丰富的 Dashboard。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>不支持消息路由，<strong>支持的客户端语言不多，目前是 java 及 c++，其中 c++ 不成熟</strong>；</li>
<li>部分支持消息有序：需要将同一类的消息 hash 到同一个队列 Queue 中，才能支持消息的顺序，如果同一类消息散落到不同的 Queue中，就不能支持消息的顺序。</li>
<li><strong>社区活跃度一般。</strong></li>
</ul>
<h5 id="rabbitmq-2">RabbitMQ</h5>
<p><strong>优点：</strong></p>
<ul>
<li><strong>支持几乎所有最受欢迎的编程语言</strong>：Java，C，C ++，C＃，Ruby，Perl，Python，PHP等等；</li>
<li><strong>支持消息路由</strong>：RabbitMQ 可以通过不同的交换器支持不同种类的消息路由；</li>
<li><strong>消息时序</strong>：通过延时队列，可以指定消息的延时时间，过期时间TTL等；</li>
<li>支持容错处理：通过交付重试和死信交换器（DLX）来处理消息处理故障；</li>
<li>提供了一个易用的用户界面，使得用户可以监控和管理消息 Broker；</li>
<li><strong>社区活跃度高。</strong></li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li><strong>Erlang 开发，很难去看懂源码，不利于做二次开发和维护</strong>，基本只能依赖于开源社区的快速维护和修复 bug；</li>
<li><strong>RabbitMQ 吞吐量会低一些</strong>，这是因为他做的实现机制比较重；</li>
<li>不支持消息有序、持久化不好、不支持消息回溯、伸缩性一般。</li>
</ul>
<h4 id="消息队列选型">消息队列选型</h4>
<ul>
<li>Kafka：追求高吞吐量，一开始的目的就是用于日志收集和传输，<strong>适合产生大量数据的互联网服务的数据收集业务</strong>，大型公司建议可以选用，<strong>如果有日志采集功能，肯定是首选 kafka。</strong></li>
<li>RocketMQ：<strong>天生为金融互联网领域而生，对于可靠性要求很高的场景</strong>，尤其是电商里面的订单扣款，以及业务削峰，在大量交易涌入时，后端可能无法及时处理的情况。RocketMQ 在稳定性上可能更值得信赖，这些业务场景在阿里双 11 已经经历了多次考验，<strong>如果你的业务有上述并发场景，建议可以选择 RocketMQ。</strong></li>
<li>RabbitMQ：结合 erlang 语言本身的并发优势，性能较好，社区活跃度也比较高，但是不利于做二次开发和维护，不过 RabbitMQ 的社区十分活跃，可以解决开发过程中遇到的 bug。<strong>如果你的数据量没有那么大，小公司优先选择功能比较完备的 RabbitMQ。</strong></li>
<li>ActiveMQ：官方社区现在对 ActiveMQ 5.x 维护越来越少，<strong>较少在大规模吞吐的场景中使用。</strong></li>
</ul>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li>
<ul>
<li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">消息队列</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%9F%BA%E7%A1%80">消息队列基础</a>
<ul>
<li><a href="#%E4%BB%80%E4%B9%88%E6%98%AF%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">什么是消息队列？</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E6%A8%A1%E5%BC%8F">消息队列模式</a></li>
<li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">消息队列应用场景</a></li>
</ul>
</li>
<li><a href="#%E5%B8%B8%E7%94%A8%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97">常用消息队列</a>
<ul>
<li><a href="#kafka">Kafka</a>
<ul>
<li><a href="#%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5">重要概念</a></li>
<li><a href="#kafka-%E6%9E%B6%E6%9E%84">Kafka 架构</a></li>
<li><a href="#kafka-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">Kafka 工作原理</a></li>
</ul>
</li>
<li><a href="#rocketmq">RocketMQ</a>
<ul>
<li><a href="#%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5-2">重要概念</a></li>
<li><a href="#rocketmq-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">RocketMQ 工作原理</a></li>
<li><a href="#rocketmq-%E6%9E%B6%E6%9E%84">RocketMQ 架构</a></li>
</ul>
</li>
<li><a href="#rabbitmq">RabbitMQ</a>
<ul>
<li><a href="#%E9%87%8D%E8%A6%81%E6%A6%82%E5%BF%B5-3">重要概念</a></li>
<li><a href="#rabbitmq-%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">RabbitMQ 工作原理</a></li>
<li><a href="#%E5%B8%B8%E7%94%A8%E4%BA%A4%E6%8D%A2%E5%99%A8">常用交换器</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94%E9%80%89%E5%9E%8B">消息队列对比&amp;选型</a>
<ul>
<li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E5%AF%B9%E6%AF%94">消息队列对比</a>
<ul>
<li><a href="#kafka-2">Kafka</a></li>
<li><a href="#rocketmq-2">RocketMQ</a></li>
<li><a href="#rabbitmq-2">RabbitMQ</a></li>
</ul>
</li>
<li><a href="#%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97%E9%80%89%E5%9E%8B">消息队列选型</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          
              <hr />
            
          
            
            <p class="next-post">上一篇：
                <a href="https://tinaxiawuhao.github.io/post/T8lb37RDN/">
                  <span class="post-title">
                    easyExcel&rarr;
                  </span>
                </a>
              </p>
            
          
            
           <p class="prev-post">下一篇：
                 <a href="https://tinaxiawuhao.github.io/post/wT9gsiZx3/">
                   <span class="post-title">
                     ExecutorCompletionService&rarr;
                   </span>
                 </a>
               </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
            <li class="list-inline-item">
              <a href="https://github.com/tinaxiawuhao" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://tinaxiawuhao.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>tianxia</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://tinaxiawuhao.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://tinaxiawuhao.github.io/media/scripts/clean-blog.min.js"></script> -->
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <div id="landlord-parent">
    <div id="landlord">
        <div class="message" style="opacity:0"></div>
        <canvas id="live2d" width="240" height="250" class="live2d"></canvas>
    </div>
</div>

<script type="text/javascript">
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)) {
        //移动端
        console.log("------ 移动端");
    } else {
        console.log("------ PC端 " + navigator.userAgent);

        addScript("https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/js/live2d.js", () => {
            // 加载完成后再loadlive2d
            loadlive2d("live2d", "https://tinaxiawuhao.github.io/media/live2d/assets/tororo.model.json");
        });

        var home_Path = "https://tinaxiawuhao.github.io/";
        addScript("https://tinaxiawuhao.github.io/media/live2d/js/message.js", () => { });
    }

    // 插入js文件，完成后callback
    function addScript(jsfile, callback) {
        var landlord_parent = document.getElementById("landlord-parent");
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = jsfile;
        landlord_parent.appendChild(script);
        script.onload = script.onreadystatechange = function () {
            if (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") {
                script.onload = script.onreadystatechange = null;
                if (callback && typeof callback == "function") {
                    callback(); //window[callback]();如果传递字符串过来 调用window['函数名']() 调用方法
                }
            }
        };
    }
</script>
  
  <script src="https://tinaxiawuhao.github.io/media/scripts/tocScript.js"></script>
</body>

</html>
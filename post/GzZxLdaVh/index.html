<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[tianxia]的个人博客">
<meta name="author" content="kveln">
<title>第七章 时间语义与 Wartermark | tianxia</title>
<link rel="stylesheet" href="https://tinaxiawuhao.github.io/resource/bootstrap.min.css">
<link href="https://tinaxiawuhao.github.io/resource/all.min.css" rel="stylesheet">
<link rel="alternate" type="application/rss+xml" title="第七章 时间语义与 Wartermark | tianxia » Feed"
  href="https://tinaxiawuhao.github.io/atom.xml">
<link rel="stylesheet"
  href="https://tinaxiawuhao.github.io/resource/androidstudio.min.css">
<link href="https://tinaxiawuhao.github.io/styles/main.css" rel="stylesheet">
<script src="https://tinaxiawuhao.github.io/resource/jquery.min.js"></script>

<script src="https://tinaxiawuhao.github.io/resource/highlight.min.js"></script>

<link rel="stylesheet" href="https://tinaxiawuhao.github.io/resource/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="第七章 时间语义与 Wartermark" />
  <meta property="og:url" content="https://tinaxiawuhao.github.io/post/GzZxLdaVh/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="tianxia" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tinaxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1657022763963"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tinaxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1657022763963"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://tinaxiawuhao.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://tinaxiawuhao.github.io/tag/1WJzfk7Hi/" class="tag">flink</a>
                
              </span>
              <h1>第七章 时间语义与 Wartermark</h1>
              <span class="meta">
                Posted on
                2021-04-14，13 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <img class="post-feature-header-image" src="https://tinaxiawuhao.github.io/post-images/GzZxLdaVh.png" alt="封面图">
          </img>
          
          <h2 id="flink-中的时间语义">Flink 中的时间语义</h2>
<p>在 Flink 的流式处理中， 会涉及到时间的不同概念， 如下图所示：<br>
<img src="https://tinaxiawuhao.github.io/post-images/1618472695574.png" alt="" loading="lazy"><br>
图 Flink 时间概念<br>
<code>Event Time</code>： 是事件创建的时间。 它通常由事件中的时间戳描述， 例如采集的<br>
日志数据中， 每一条日志都会记录自己的生成时间， Flink 通过时间戳分配器访问事<br>
件时间戳。<br>
<code>Ingestion Time</code>： 是数据进入 Flink 的时间。<br>
<code>Processing Time</code>： 是每一个执行基于时间操作的算子的本地系统时间， 与机器<br>
相关， 默认的时间属性就是 Processing Time。<br>
一个例子——电影《 星球大战》 ：<br>
<img src="https://tinaxiawuhao.github.io/post-images/1618472731095.png" alt="" loading="lazy"><br>
例如， 一条日志进入 Flink 的时间为 2020-11-12 10:00:00.123， 到达 Window 的<br>
系统时间为 2020-11-12 10:00:01.234， 日志的内容如下：</p>
<pre><code class="language-sh">2020-11-02 18:37:15.624 INFO Fail over to rm2
</code></pre>
<p>对于业务来说， 要统计 1min 内的故障日志个数， 哪个时间是最有意义的？ ——<br>
eventTime， 因为我们要根据日志的生成时间进行统计。</p>
<h2 id="eventtime-的引入">EventTime 的引入</h2>
<p style="text-indent:2em">在 Flink 的流式处理中， 绝大部分的业务都会使用 eventTime， 一般只在eventTime 无法使用时， 才会被迫使用 ProcessingTime 或者 IngestionTime。
如果要使用 EventTime， 那么需要引入 EventTime 的时间属性， 引入方式如下所
示：</p>
<pre><code class="language-java">// 创建 execution environment
StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
        // 告诉系统按照 EventTime 处理
env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
</code></pre>
<h2 id="watermark">Watermark</h2>
<h3 id="基本概念">基本概念</h3>
<p style="text-indent:2em">我们知道， 流处理从事件产生， 到流经 source， 再到 operator， 中间是有一个过程和时间的， 虽然大部分情况下， 流到 operator 的数据都是按照事件产生的时间顺序来的， 但是也不排除由于网络、 分布式等原因， 导致乱序的产生， 所谓乱序， 就
是指 Flink 接收到的事件的先后顺序不是严格按照事件的 Event Time 顺序排列的。</p>
<p><img src="https://tinaxiawuhao.github.io/post-images/1618472852122.png" alt="" loading="lazy"><br>
图 数据的乱序</p>
<p style="text-indent:2em">那么此时出现一个问题， 一旦出现乱序， 如果只根据 eventTime 决定 window 的运行， 我们不能明确数据是否全部到位， 但又不能无限期的等下去， 此时必须要有
个机制来保证一个特定的时间后， 必须触发 window 去进行计算了， 这个特别的机
制， 就是 Watermark。</p>
<ol>
<li>Watermark 是一种衡量 Event Time 进展的机制。</li>
<li>Watermark 是用于处理乱序事件的， 而正确的处理乱序事件， 通常用<br>
Watermark 机制结合 window 来实现。</li>
<li>数据流中的 Watermark 用于表示 timestamp 小于 Watermark 的数据， 都已经<br>
到达了， 因此， window 的执行也是由 Watermark 触发的。</li>
<li>Watermark 可以理解成一个延迟触发机制， 我们可以设置 Watermark 的延时<br>
时长 t， 每次系统会校验已经到达的数据中最大的 maxEventTime， 然后认定 eventTime<br>
小于 maxEventTime - t 的所有数据都已经到达， 如果有窗口的停止时间等于<br>
maxEventTime – t， 那么这个窗口被触发执行。<br>
有序流的 Watermarker 如下图所示： （ Watermark 设置为 0）<br>
<img src="https://tinaxiawuhao.github.io/post-images/1618472893459.png" alt="" loading="lazy"><br>
图 有序数据的 Watermark<br>
乱序流的 Watermarker 如下图所示： （ Watermark 设置为 2）<br>
<img src="https://tinaxiawuhao.github.io/post-images/1618472899867.png" alt="" loading="lazy"><br>
图 无序数据的 Watermark</li>
</ol>
<p style="text-indent:2em">当 Flink 接收到数据时， 会按照一定的规则去生成 Watermark， 这条 Watermark
就等于当前所有到达数据中的 maxEventTime - 延迟时长， 也就是说， Watermark 是
基于数据携带的时间戳生成的， 一旦 Watermark 比当前未触发的窗口的停止时间要
晚， 那么就会触发相应窗口的执行。 由于 event time 是由数据携带的， 因此， 如果
运行过程中无法获取新的数据， 那么没有被触发的窗口将永远都不被触发。</p>
<p style="text-indent:2em">上图中， 我们设置的允许最大延迟到达时间为 2s， 所以时间戳为 7s 的事件对应
的 Watermark 是 5s， 时间戳为 12s 的事件的 Watermark 是 10s， 如果我们的窗口 1
是 1s~5s， 窗口 2 是 6s~10s， 那么时间戳为 7s 的事件到达时的 Watermarker 恰好触
发窗口 1， 时间戳为 12s 的事件到达时的 Watermark 恰好触发窗口 2。Watermark 就是触发前一窗口的“ 关窗时间” ， 一旦触发关门那么以当前时刻为准在窗口范围内的所有所有数据都会收入窗中。
只要没有达到水位那么不管现实中的时间推进了多久都不会触发关窗。</p>
<h3 id="watermark-的引入">Watermark 的引入</h3>
<p>watermark 的引入很简单， 对于乱序数据， 最常见的引用方式如下：</p>
<pre><code class="language-java">// 抽取出时间和生成 watermark
dataStream.assignTimestampsAndWatermarks(new AscendingTimestampExtractor&lt;UserBehavior&gt;() {
    @Override
    public long extractAscendingTimestamp(UserBehavior userBehavior) {
        // 原始数据单位秒，将其转成毫秒
        return userBehavior.timestamp * 1000;
    }
})
</code></pre>
<p style="text-indent:2em">Event Time 的使用一定要指定数据源中的时间戳。 否则程序无法知道事件的事
件时间是什么(数据源里的数据没有时间戳的话， 就只能使用 Processing Time 了)。
我们看到上面的例子中创建了一个看起来有点复杂的类， 这个类实现的其实就
是分配时间戳的接口。 Flink 暴露了 TimestampAssigner 接口供我们实现， 使我们可
以自定义如何从事件数据中抽取时间戳。</p>
<pre><code class="language-java">// 创建 execution environment
final StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
// 通过连接 socket 获取输入数据，这里连接到本地9000端口，如果9000端口已被占用，请换一个端口
DataStream&lt;String&gt; text = env.socketTextStream(&quot;localhost&quot;, 9000, &quot;\n&quot;);
text.assignTimestampsAndWatermarks(new MyAssigner())
</code></pre>
<p>MyAssigner 有两种类型</p>
<ol>
<li>AssignerWithPeriodicWatermarks</li>
<li>AssignerWithPunctuatedWatermarks<br>
以上两个接口都继承自 TimestampAssigner。</li>
</ol>
<h3 id="assigner-with-periodic-watermarks">Assigner with periodic watermarks</h3>
<p>周期性的生成 watermark： 系统会周期性的将 watermark 插入到流中(水位线也<br>
是一种特殊的事件!)。 默认周期是 200 毫秒。 可以使用<br>
ExecutionConfig.setAutoWatermarkInterval()方法进行设置。</p>
<pre><code class="language-java">StreamExecutionEnvironment env = StreamExecutionEnvironment.getExecutionEnvironment();
env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime)
// 每隔 5 秒产生一个 watermark
env.getConfig.setAutoWatermarkInterval(5000)
</code></pre>
<p style="text-indent:2em">产生 watermark 的逻辑： 每隔 5 秒钟， Flink 会调用
AssignerWithPeriodicWatermarks 的 getCurrentWatermark()方法。 如果方法返回一个
时间戳大于之前水位的时间戳， 新的 watermark 会被插入到流中。 这个检查保证了
水位线是单调递增的。 如果方法返回的时间戳小于等于之前水位的时间戳， 则不会
产生新的 watermark。</p>
<p>例子， 自定义一个周期性的时间戳抽取：</p>
<pre><code class="language-java">public class PeriodicAssigner extends
AssignerWithPeriodicWatermarks&lt;SensorReading&gt; {
    Long bound= 60 * 1000 // 延时为 1 分钟
    Long maxTs = Long.MinValue // 观察到的最大时间戳
    public Watermark  getCurrentWatermark() {
        new Watermark(maxTs - bound)
    } 
    public void extractTimestamp(SensorReading r,Long previousTS) = {
        maxTs = maxTs.max(r.timestamp)
        r.timestamp
    }
}
</code></pre>
<p style="text-indent:2em">一种简单的特殊情况是， 如果我们事先得知数据流的时间戳是单调递增的， 也就是说没有乱序， 那我们可以使用 assignAscendingTimestamps， 这个方法会直接使
用数据的时间戳生成 watermark。</p>
<pre><code class="language-java">DataStream&lt;SensorReading&gt; stream:  = ...
DataStream&lt;SensorReading&gt; withTimestampsAndWatermarks = stream
.assignAscendingTimestamps(e =&gt; e.timestamp)
&gt;&gt; result: E(1), W(1), E(2), W(2), ...
</code></pre>
<p>而对于乱序数据流， 如果我们能大致估算出数据流中的事件的最大延迟时间，<br>
就可以使用如下代码：</p>
<pre><code class="language-java">DataStream&lt;SensorReading&gt; stream:  = ...
DataStream&lt;SensorReading&gt; withTimestampsAndWatermarks = stream.assignTimestampsAndWatermarks(
    new SensorTimeAssigner()
) 
public class SensorTimeAssigner extends
BoundedOutOfOrdernessTimestampExtractor&lt;SensorReading&gt;(Time.seconds(5)) {
    // 抽取时间戳
    public Long  extractTimestamp(SensorReading r){
        return r.timestamp
    }
}
&gt;&gt; relust: E(10), W(0), E(8), E(7), E(11), W(1), ...
</code></pre>
<h3 id="assigner-with-punctuated-watermarks">Assigner with punctuated watermarks</h3>
<p style="text-indent:2em">间断式地生成 watermark。 和周期性生成的方式不同， 这种方式不是固定时间的，而是可以根据需要对每条数据进行筛选和处理。 直接上代码来举个例子， 我们只给
sensor_1 的传感器的数据流插入 watermark：</p>
<pre><code class="language-java">public class PunctuatedAssigner extends
    AssignerWithPunctuatedWatermarks&lt;SensorReading&gt; {
    Long bound=60 * 1000
    public  Watermark checkAndGetNextWatermark(SensorReading r , Long extractedTS) {
        if (r.id == &quot;sensor_1&quot;) {
            new Watermark(extractedTS - bound)
        } else {
            null
         }
    } 
    public  Long extractTimestamp(SensorReading r, Long previousTS){
        return  r.timestamp
    }
}
</code></pre>
<h2 id="evnettime-在-window-中的使用">EvnetTime 在 window 中的使用</h2>
<h3 id="滚动窗口tumblingeventtimewindows">滚动窗口（TumblingEventTimeWindows）</h3>
<pre><code class="language-java">public class EventTimeTumblingWindowAllDemo {
    public static void main(String[] args) throws Exception {
        //  2021-03-06 21:00:00,1
        //  2021-03-06 21:00:05,2
        // 结果 ： 2&gt; 1
        //        3&gt; 2
        StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(new Configuration());
        // 老版本必须要设置时间标准 （1.20 之前的）
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        DataStreamSource&lt;String&gt; lines = env.socketTextStream(&quot;linux01&quot;, 8888);
       // flink里面的时间都精确到毫秒
       //  时间提取器 BoundedOutOfOrdernessTimestampExtractor : 允许时间乱序，并且可以指定窗口延时
       // WaterMark （水位线，可以让窗口延迟触发的一种机制）
       // 一个窗口中的一个分区的水位线 = 当前窗口当前分区最大的 EventTime - 延迟时间     Time.seconds(0)
        SingleOutputStreamOperator&lt;String&gt; linesWithWaterMark = lines.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor&lt;String&gt;(Time.seconds(0)) {

            private SimpleDateFormat dateFormat = new SimpleDateFormat(&quot;yyyy-MM-dd HH:mm:ss&quot;) ;
            @Override
            public long extractTimestamp(String s) {
                String strings = s.split(&quot;,&quot;)[0];
                long timestamp = 0;
                try {
                    Date date = dateFormat.parse(strings);
                    timestamp = date.getTime();
                } catch (ParseException e) {
                    e.printStackTrace();
                    timestamp = System.currentTimeMillis();
                }
                return timestamp;
            }
        });

        SingleOutputStreamOperator&lt;Integer&gt; nums = linesWithWaterMark.map(new MapFunction&lt;String, Integer&gt;() {
            @Override
            public Integer map(String s) throws Exception {
                int i = Integer.parseInt(s.split(&quot;,&quot;)[1]);
                return i;
            }
        });
        //  划分窗口
        AllWindowedStream&lt;Integer, TimeWindow&gt; window = nums.windowAll(TumblingProcessingTimeWindows.of(Time.seconds(5)));
        // 对 window 中的数据 进行聚合
        SingleOutputStreamOperator&lt;Integer&gt; sum = window.sum(0);

        sum.print();
        env.execute() ;


    }
}
</code></pre>
<p>结果是按照 Event Time 的时间窗口计算得出的， 而无关系统的时间（ 包括输入的快慢） 。</p>
<h3 id="滑动窗口slidingeventtimewindows">滑动窗口（SlidingEventTimeWindows）</h3>
<pre><code class="language-java">public class EventTimeSlidingWindowDemo {
    public static void main(String[] args) throws Exception {

        StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(new Configuration());
         //  两秒 调一次方法
        env.getConfig().setAutoWatermarkInterval(1000);
        // 老版本必须要设置时间标准 （1.20 之前的）
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        DataStreamSource&lt;String&gt; lines = env.socketTextStream(&quot;linux01&quot;, 8888);
       // flink里面的时间都精确到毫秒
       //  时间提取器 BoundedOutOfOrdernessTimestampExtractor : 允许时间乱序，并且可以指定窗口延时
       // WaterMark （水位线，可以让窗口延迟触发的一种机制）
       // 一个窗口中的一个分区的水位线 = 当前窗口当前分区最大的 EventTime - 延迟时间     Time.seconds(0)
        SingleOutputStreamOperator&lt;String&gt; linesWithWaterMark = lines.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor&lt;String&gt;(Time.seconds(0)) {


            @Override
            public long extractTimestamp(String s) {
                return Long.parseLong(s.split(&quot;,&quot;)[0]); // EventTime
            }
        });
       //   提取完 EventTime 后生成 WaterMark ，但数据还是原来的老样子
       // 1000,spark,1 --&gt; spark,1
        SingleOutputStreamOperator &lt;Tuple2&lt;String,Integer&gt;&gt; WordAndCount = linesWithWaterMark.map(new MapFunction&lt;String, Tuple2&lt;String,Integer&gt;&gt;() {

            @Override
            public Tuple2&lt;String,Integer&gt; map(String s) throws Exception {
                String[] split = s.split(&quot;,&quot;);
                return Tuple2.of(split[1],Integer.parseInt(split[2]));
            }
        });

        //  先 keyBy，再划分窗口
        KeyedStream&lt;Tuple2&lt;String, Integer&gt;, String&gt; keyed = WordAndCount.keyBy(t -&gt; t.f0);

        //   划分窗口
        WindowedStream&lt;Tuple2&lt;String, Integer&gt;, String, TimeWindow&gt; window = keyed.window(SlidingEventTimeWindows.of(Time.seconds(10), Time.seconds(5)));
         //  对窗口里面的数据进行 sum
        SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; sum = window.sum(1);
        sum.print();
        env.execute() ;
    }
}
</code></pre>
<h3 id="会话窗口eventtimesessionwindows">会话窗口（EventTimeSessionWindows）</h3>
<p style="text-indent:2em">相邻两次数据的 EventTime 的时间差超过指定的时间间隔就会触发执行。 如果加入 Watermark， 会在符合窗口触发的情况下进行延迟。 到达延迟水位再进行窗口
触发。</p>
<pre><code class="language-java">public class EventTimeSessionWindowDemo {
    public static void main(String[] args) throws Exception {

        StreamExecutionEnvironment env = StreamExecutionEnvironment.createLocalEnvironmentWithWebUI(new Configuration());
         //  两秒 调一次方法
        env.getConfig().setAutoWatermarkInterval(1000);
        // 老版本必须要设置时间标准 （1.20 之前的）
        env.setStreamTimeCharacteristic(TimeCharacteristic.EventTime);
        DataStreamSource&lt;String&gt; lines = env.socketTextStream(&quot;linux01&quot;, 8888);
       // flink里面的时间都精确到毫秒
       //  时间提取器 BoundedOutOfOrdernessTimestampExtractor : 允许时间乱序，并且可以指定窗口延时
       // WaterMark （水位线，可以让窗口延迟触发的一种机制）
       // 一个窗口中的一个分区的水位线 = 当前窗口当前分区最大的 EventTime - 延迟时间     Time.seconds(0)
        SingleOutputStreamOperator&lt;String&gt; linesWithWaterMark = lines.assignTimestampsAndWatermarks(new BoundedOutOfOrdernessTimestampExtractor&lt;String&gt;(Time.seconds(0)) {


            @Override
            public long extractTimestamp(String s) {
                return Long.parseLong(s.split(&quot;,&quot;)[0]); // EventTime
            }
        });
       //   提取完 EventTime 后生成 WaterMark ，但数据还是原来的老样子
       // 1000,spark,1 --&gt; spark,1
        SingleOutputStreamOperator &lt;Tuple2&lt;String,Integer&gt;&gt; WordAndCount = linesWithWaterMark.map(new MapFunction&lt;String, Tuple2&lt;String,Integer&gt;&gt;() {

            @Override
            public Tuple2&lt;String,Integer&gt; map(String s) throws Exception {
                String[] split = s.split(&quot;,&quot;);
                return Tuple2.of(split[1],Integer.parseInt(split[2]));
            }
        });

        //  先 keyBy，再划分窗口
        KeyedStream&lt;Tuple2&lt;String, Integer&gt;, String&gt; keyed = WordAndCount.keyBy(t -&gt; t.f0);

        //   划分窗口
        WindowedStream&lt;Tuple2&lt;String, Integer&gt;, String, TimeWindow&gt; window = keyed.window(EventTimeSessionWindows.withGap(Time.seconds(5)));
         //  对窗口里面的数据进行 sum
        SingleOutputStreamOperator&lt;Tuple2&lt;String, Integer&gt;&gt; sum = window.sum(1);

        sum.print();
        env.execute() ;


    }
}
</code></pre>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#flink-%E4%B8%AD%E7%9A%84%E6%97%B6%E9%97%B4%E8%AF%AD%E4%B9%89">Flink 中的时间语义</a></li>
<li><a href="#eventtime-%E7%9A%84%E5%BC%95%E5%85%A5">EventTime 的引入</a></li>
<li><a href="#watermark">Watermark</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5">基本概念</a></li>
<li><a href="#watermark-%E7%9A%84%E5%BC%95%E5%85%A5">Watermark 的引入</a></li>
<li><a href="#assigner-with-periodic-watermarks">Assigner with periodic watermarks</a></li>
<li><a href="#assigner-with-punctuated-watermarks">Assigner with punctuated watermarks</a></li>
</ul>
</li>
<li><a href="#evnettime-%E5%9C%A8-window-%E4%B8%AD%E7%9A%84%E4%BD%BF%E7%94%A8">EvnetTime 在 window 中的使用</a>
<ul>
<li><a href="#%E6%BB%9A%E5%8A%A8%E7%AA%97%E5%8F%A3tumblingeventtimewindows">滚动窗口（TumblingEventTimeWindows）</a></li>
<li><a href="#%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3slidingeventtimewindows">滑动窗口（SlidingEventTimeWindows）</a></li>
<li><a href="#%E4%BC%9A%E8%AF%9D%E7%AA%97%E5%8F%A3eventtimesessionwindows">会话窗口（EventTimeSessionWindows）</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
          
              <hr />
            
          
            
            <p class="next-post">上一篇：
                <a href="https://tinaxiawuhao.github.io/post/5uA_yv-aO/">
                  <span class="post-title">
                    第六章 Flink 的Window 操作&rarr;
                  </span>
                </a>
              </p>
            
          
            
           <p class="prev-post">下一篇：
                 <a href="https://tinaxiawuhao.github.io/post/cctea1w9G/">
                   <span class="post-title">
                     第八章 ProcessFunction API（底层 API）&rarr;
                   </span>
                 </a>
               </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
            <li class="list-inline-item">
              <a href="https://github.com/tinaxiawuhao" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://tinaxiawuhao.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>tianxia</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://tinaxiawuhao.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://tinaxiawuhao.github.io/media/scripts/clean-blog.min.js"></script> -->
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <div id="landlord-parent">
    <div id="landlord">
        <div class="message" style="opacity:0"></div>
        <canvas id="live2d" width="240" height="250" class="live2d"></canvas>
    </div>
</div>

<script type="text/javascript">
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)) {
        //移动端
        console.log("------ 移动端");
    } else {
        console.log("------ PC端 " + navigator.userAgent);

        addScript("https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/js/live2d.js", () => {
            // 加载完成后再loadlive2d
            loadlive2d("live2d", "https://tinaxiawuhao.github.io/media/live2d/assets/tororo.model.json");
        });

        var home_Path = "https://tinaxiawuhao.github.io/";
        addScript("https://tinaxiawuhao.github.io/media/live2d/js/message.js", () => { });
    }

    // 插入js文件，完成后callback
    function addScript(jsfile, callback) {
        var landlord_parent = document.getElementById("landlord-parent");
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = jsfile;
        landlord_parent.appendChild(script);
        script.onload = script.onreadystatechange = function () {
            if (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") {
                script.onload = script.onreadystatechange = null;
                if (callback && typeof callback == "function") {
                    callback(); //window[callback]();如果传递字符串过来 调用window['函数名']() 调用方法
                }
            }
        };
    }
</script>
  
  <script src="https://tinaxiawuhao.github.io/media/scripts/tocScript.js"></script>
</body>

</html>
<!DOCTYPE html>
<html>

<head>
  <meta http-equiv="content-type" content="text/html; charset=utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta content="yes" name="apple-mobile-web-app-capable" />
<meta content="black" name="apple-mobile-web-app-status-bar-style" />
<meta name="referrer" content="never">
<meta name="keywords" content="">
<meta name="description" content="欢迎访问[tianxia]的个人博客">
<meta name="author" content="kveln">
<title>数据结构常见的八大排序算法 | tianxia</title>
<link rel="stylesheet" href="https://tinaxiawuhao.github.io/resource/bootstrap.min.css">
<link href="https://tinaxiawuhao.github.io/resource/all.min.css" rel="stylesheet">
<link rel="alternate" type="application/rss+xml" title="数据结构常见的八大排序算法 | tianxia » Feed"
  href="https://tinaxiawuhao.github.io/atom.xml">
<link rel="stylesheet"
  href="https://tinaxiawuhao.github.io/resource/androidstudio.min.css">
<link href="https://tinaxiawuhao.github.io/styles/main.css" rel="stylesheet">
<script src="https://tinaxiawuhao.github.io/resource/jquery.min.js"></script>

<script src="https://tinaxiawuhao.github.io/resource/highlight.min.js"></script>

<link rel="stylesheet" href="https://tinaxiawuhao.github.io/resource/live2d.css">

<script>hljs.initHighlightingOnLoad();</script>

  <meta property="og:description" content="数据结构常见的八大排序算法" />
  <meta property="og:url" content="https://tinaxiawuhao.github.io/post/0BBhLzjWl/" />
  <meta property="og:locale" content="zh-CN" />
  <meta property="og:type" content="website" />
  <meta property="og:site_name" content="tianxia" />
  <!-- <script src="../assets/styles/scripts/tocScript.js"></script> -->
</head>

<body>
  <!-- Navigation -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tinaxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1663409015113"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
  <!-- Page Header -->
  <nav class="navbar navbar-expand-lg navbar-light fixed-top" id="mainNav">
  <div class="container">
    <a class="navbar-brand" href="https://tinaxiawuhao.github.io">tianxia</a>
    <button class="navbar-toggler navbar-toggler-right" type="button" data-toggle="collapse"
      data-target="#navbarResponsive" aria-controls="navbarResponsive" aria-expanded="false"
      aria-label="Toggle navigation">
      Menu
      <i class="fas fa-bars"></i>
    </button>
    <div class="collapse navbar-collapse" id="navbarResponsive">
      <ul class="navbar-nav ml-auto">
        
        <li class="nav-item">
          
          <a class="nav-link" href="/">首页</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/archives">归档</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/tags">标签</a>
          
        </li>
        
        <li class="nav-item">
          
          <a class="nav-link" href="/post/about">关于</a>
          
        </li>
        
        <li class="nav-item">
          <div class="gridea-search-container">
            <form id="gridea-search-form" style="position: relative" data-update="1663409015113"
              action="/search/index.html">
              <input class="search-input" autocomplete="off" spellcheck="false" name="q" placeholder="搜索文章" />
              <i class="fas fa-search gt-c-content-color-first" style="position: absolute; top: 9px; left: 10px;"></i>
            </form>
          </div>
        </li>
      </ul>
    </div>
  </div>
</nav>
<header class="masthead" style="background-image: url('https://tinaxiawuhao.github.io/media/images/home-bg.jpg')">
  <div class="overlay"></div>
  <div class="container">
    <div class="row">
      <div class="col-lg-8 col-md-10 mx-auto">
        
          <!-- 没Title为其他页面Header -->
          
            <!-- 没Title并且有headerType为Post：文章Header -->
            <div class="post-heading">
              <span class="tags">
                
                <a href="https://tinaxiawuhao.github.io/tag/3wn3aAbld/" class="tag">算法</a>
                
                <a href="https://tinaxiawuhao.github.io/tag/gvtXj5hZZ/" class="tag">java</a>
                
              </span>
              <h1>数据结构常见的八大排序算法</h1>
              <span class="meta">
                Posted on
                2021-04-25，22 min read
              </span>
            </div>
          
        
      </div>
    </div>
  </div>
</header>
  <!-- Post Content -->
  <article id="post-content-article">
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto post-content-container">
          
          <img class="post-feature-header-image" src="https://tinaxiawuhao.github.io/post-images/0BBhLzjWl.png" alt="封面图">
          </img>
          
          <p>八大排序，三大查找是《数据结构》当中非常基础的知识点，在这里为了复习顺带总结了一下常见的八种排序算法。</p>
<p>常见的八大排序算法，他们之间关系如下：</p>
<figure data-type="image" tabindex="1"><img src="https://tinaxiawuhao.github.io/post-images/1619339616659.png" alt="" loading="lazy"></figure>
<p>他们的性能比较：</p>
<figure data-type="image" tabindex="2"><img src="https://tinaxiawuhao.github.io/post-images/1619339624226.png" alt="" loading="lazy"></figure>
<p>下面，利用java分别将他们进行实现。</p>
<h2 id="直接插入排序">直接插入排序</h2>
<h3 id="算法思想">算法思想：</h3>
<figure data-type="image" tabindex="3"><img src="https://tinaxiawuhao.github.io/post-images/1619339633556.gif" alt="" loading="lazy"></figure>
<p>直接插入排序的核心思想就是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。</p>
<p>因此，从上面的描述中我们可以发现，直接插入排序可以用两个循环完成：</p>
<ol>
<li>第一层循环：遍历待比较的所有数组元素</li>
<li>第二层循环：将本轮选择的元素(selected)与已经排好序的元素(ordered)相比较。</li>
</ol>
<p>如果：selected &lt; ordered，那么将二者交换</p>
<h3 id="代码实现">代码实现</h3>
<pre><code class="language-java">package sort;

import java.util.Arrays;

/**
 * @author wuhao
 * @desc 直接插入排序
 * @date 2020-12-02 15:04:57
 * 直接插入排序的核心思想就是：将数组中的所有元素依次跟前面已经排好的元素相比较，如果选择的元素比已排序的元素小，则交换，直到全部元素都比较过。
 * 因此，从上面的描述中我们可以发现，直接插入排序可以用两个循环完成：
 * 第一层循环：遍历待比较的所有数组元素
 * 第二层循环：将本轮选择的元素(selected)与已经排好序的元素(ordered)相比较。
 * 如果：selected &lt; ordered，那么将二者交换
 */
public class DirectInsertionSort {
    public static void main(String[] args) {
        int[] arr = {12, 32, 22, 7, 48};
        insertSort(arr);
    }

    private static void insertSort(int[] arr) {
       for (int i = 1; i &lt; arr.length; i++) {
           int temp = arr[i];
           int j;
           for (j = i - 1; j &gt;= 0; j--) {
               if (temp &lt; arr[j]) {
                   arr[j + 1] = arr[j];
               } else {
                   break;
               }
           }
           arr[j + 1] = temp;
       }

        System.out.println(Arrays.toString(arr));
    }
}

</code></pre>
<h2 id="希尔排序">希尔排序</h2>
<h3 id="算法思想-2">算法思想：</h3>
<figure data-type="image" tabindex="4"><img src="https://tinaxiawuhao.github.io/post-images/1619339644637.png" alt="" loading="lazy"></figure>
<p>希尔排序的算法思想：将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。</p>
<p>同样的：从上面的描述中我们可以发现：希尔排序的总体实现应该由三个循环完成：</p>
<ol>
<li>第一层循环：将gap依次折半，对序列进行分组，直到gap=1</li>
<li>第二、三层循环：也即直接插入排序所需要的两次循环。具体描述见上。</li>
</ol>
<h3 id="代码实现-2">代码实现</h3>
<pre><code class="language-java">package sort;

import java.util.Arrays;

/**
 * @author wuhao
 * @desc 希尔排序
 * @date 2020-12-02 15:20:43
 * 希尔排序的算法思想：将待排序数组按照步长gap进行分组，然后将每组的元素利用直接插入排序的方法进行排序；每次将gap折半减小，循环上述操作；当gap=1时，利用直接插入，完成排序。
 * 同样的：从上面的描述中我们可以发现：希尔排序的总体实现应该由三个循环完成：
 * 第一层循环：将gap依次折半，对序列进行分组，直到gap=1
 * 第二、三层循环：也即直接插入排序所需要的两次循环。具体描述见上。
 */
public class HillSort {
    public static void main(String[] args) {
        int[] arr = {12, 32, 22, 7, 48, 3, 5, 6, 8, 24};
        shellSort(arr);
    }

    private static void shellSort(int[] arr) {
        for (int step = arr.length / 2; step &gt; 0; step /= 2) {
//            for (int i = step; i &lt; arr.length; i++) {
//                int temp = arr[i];
//                int j;
//                for (j = i - step; j &gt;= 0 &amp;&amp; arr[j] &gt; temp; j -= step) {
//                    arr[j + step] = arr[j];
//                }
//                arr[j + step] = temp;
//            }
            for (int i = step; i &lt; arr.length; i++) {
                int k=i;
                for (int j = i-step; j &gt;=0 &amp;&amp; arr[j] &gt; arr[k]; j -= step,k -=step) {
                   int temp = arr[j];
                    arr[j]= arr[k];
                    arr[k]=temp;
                }
            }
        }

        System.out.println(Arrays.toString(arr));

    }
}

</code></pre>
<h2 id="简单选择排序">简单选择排序</h2>
<h3 id="算法思想-3">算法思想</h3>
<figure data-type="image" tabindex="5"><img src="https://tinaxiawuhao.github.io/post-images/1619339776440.gif" alt="" loading="lazy"></figure>
<p>简单选择排序的基本思想：比较+交换。</p>
<ol>
<li>从待排序序列中，找到关键字最小的元素；</li>
<li>如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；</li>
<li>从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。</li>
</ol>
<p>因此我们可以发现，简单选择排序也是通过两层循环实现。</p>
<p>第一层循环：依次遍历序列当中的每一个元素</p>
<p>第二层循环：将遍历得到的当前元素依次与余下的元素进行比较，符合最小元素的条件，则交换。</p>
<h3 id="代码实现-3">代码实现</h3>
<pre><code class="language-java">package sort;

import java.util.Arrays;

/**
 * @author wuhao
 * @desc 简单选择排序
 * @date 2020-12-02 16:21:47
 * 简单选择排序的基本思想：比较+交换。
 * 从待排序序列中，找到关键字最小的元素；
 * 如果最小元素不是待排序序列的第一个元素，将其和第一个元素互换；
 * 从余下的 N - 1 个元素中，找出关键字最小的元素，重复(1)、(2)步，直到排序结束。
 * 因此我们可以发现，简单选择排序也是通过两层循环实现。
 * 第一层循环：依次遍历序列当中的每一个元素
 * 第二层循环：将遍历得到的当前元素依次与余下的元素进行比较，符合最小元素的条件，则交换。
 */
public class SimpleSelectionSort {
    public static void main(String[] args) {
        int[] arr = {12, 32, 22, 7, 48, 3, 5, 6, 8, 24};
        selectionSort(arr);
    }

    private static void selectionSort(int[] arr) {
        for (int i = 0; i &lt; arr.length; i++) {
            int k = i;
            for (int j = i + 1; j &lt; arr.length; j++) {
                if (arr[j] &lt; arr[k]) {
                    k = j;
                }
            }
            if (k != i) {
                int temp = arr[i];
                arr[i] = arr[k];
                arr[k] = temp;
            }


        }
        System.out.println(Arrays.toString(arr));
    }
}
</code></pre>
<h2 id="堆排序">堆排序</h2>
<h3 id="堆的概念">堆的概念</h3>
<p>堆：本质是一种数组对象。特别重要的一点性质：<b>任意的叶子节点小于（或大于）它所有的父节点</b>。对此，又分为大顶堆和小顶堆，大顶堆要求节点的元素都要大于其孩子，小顶堆要求节点元素都小于其左右孩子，两者对左右孩子的大小关系不做任何要求。</p>
<p>利用堆排序，就是基于大顶堆或者小顶堆的一种排序方法。下面，我们通过大顶堆来实现。</p>
<h3 id="基本思想">基本思想：</h3>
<p>堆排序可以按照以下步骤来完成：</p>
<figure data-type="image" tabindex="6"><img src="https://tinaxiawuhao.github.io/post-images/1619339787440.png" alt="" loading="lazy"></figure>
<p>构建大顶堆.png</p>
<figure data-type="image" tabindex="7"><img src="https://tinaxiawuhao.github.io/post-images/1619339794481.png" alt="" loading="lazy"></figure>
<p>Paste_Image.png</p>
<ol>
<li>构建初始堆，将待排序列构成一个大顶堆(或者小顶堆)，升序大顶堆，降序小顶堆；</li>
<li>将堆顶元素与堆尾元素交换，并断开(从待排序列中移除)堆尾元素。</li>
<li>重新构建堆。</li>
<li>重复2~3，直到待排序列中只剩下一个元素(堆顶元素)。</li>
</ol>
<h3 id="代码实现-4">代码实现：</h3>
<pre><code class="language-java">package sort;

import java.util.Arrays;

/**
 * @author wuhao
 * @desc 堆排序
 * @date 2020-12-04 09:13:58
 * 堆排序可以按照以下步骤来完成：
 * 首先将序列构建称为大顶堆；
 * （这样满足了大顶堆那条性质：位于根节点的元素一定是当前序列的最大值）
 * 取出当前大顶堆的根节点，将其与序列末尾元素进行交换；
 * （此时：序列末尾的元素为已排序的最大值；由于交换了元素，当前位于根节点的堆并不一定满足大顶堆的性质）
 * 对交换后的n-1个序列元素进行调整，使其满足大顶堆的性质；
 * 重复2.3步骤，直至堆中只有1个元素为止
 */
public class HeapSort {
    public static void main(String[] args) {
        int[] arr = {11, 44, 23, 67, 88, 65, 34, 48, 9, 12};
        heapSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    private static void heapSort(int[] a) {
        // 首先需要创建根堆
        for (int i = a.length / 2; i &gt;= 0; i--) { // 从最后一个非终端结点开始，然后一次--
            HeapAdjust(a, i, a.length);
        }

        for (int i = a.length - 1; i &gt; 0; --i) {// 这个循环是把最大值a[0]放到末尾 ，
            int temp = a[0];
            a[0] = a[i]; // 此时i代表最后一个元素
            a[i] = temp;
            HeapAdjust(a, 0, i );
        }
    }

    // 调整堆
    private static void HeapAdjust(int[] a, int parent, int m) {// parent代表当前 m代表最后
        int temp = a[parent]; // 先把a[parent]的值赋给temp保存起来
        for (int j = 2 * parent; j &lt; m; j *= 2) {
            if (j+1 &lt; m &amp;&amp; a[j] &lt; a[j + 1]) { // 判断是a[parent]大还是a[j + 1]大，如果a[j + 1]大 就++j，把j换成当前最大
                j++;
            }
            if (temp &gt;= a[j]) { // 如果temp中比最大值还大，代表本身就是一个根堆，break
                break;// 如果大于，就代表当前为大跟对，退出
            }
            a[parent] = a[j];// 否则就把最大给[parent]
            parent = j;// 然后把最大下标给parent，继续循环,检查是否因为调整根堆而破坏了子树
        }
        a[parent] = temp;
    }

    /**
     * 创建堆，
     * @param arr 待排序列
     */
//    private static void heapSort(int[] arr) {
//        //创建堆
//        for (int i = (arr.length - 1) / 2; i &gt;= 0; i--) {
//            //从第一个非叶子结点从下至上，从右至左调整结构
//            adjustHeap(arr, i, arr.length);
//        }
//
//        //调整堆结构+交换堆顶元素与末尾元素
//        for (int i = arr.length - 1; i &gt; 0; i--) {
//            //将堆顶元素与末尾元素进行交换
//            int temp = arr[i];
//            arr[i] = arr[0];
//            arr[0] = temp;
//
//            //重新对堆进行调整
//            adjustHeap(arr, 0, i);
//        }
//    }

    /**
     * 调整堆
     * @param arr 待排序列
     * @param parent 父节点
     * @param length 待排序列尾元素索引
     */
//    private static void adjustHeap(int[] arr, int parent, int length) {
//        //将temp作为父节点
//        int temp = arr[parent];
//        //左孩子
//        int lChild = 2 * parent + 1;
//
//        while (lChild &lt; length) {
//            //右孩子
//            int rChild = lChild + 1;
//            // 如果有右孩子结点，并且右孩子结点的值大于左孩子结点，则选取右孩子结点
//            if (rChild &lt; length &amp;&amp; arr[lChild] &lt; arr[rChild]) {
//                lChild++;
//            }
//
//            // 如果父结点的值已经大于孩子结点的值，则直接结束
//            if (temp &gt;= arr[lChild]) {
//                break;
//            }
//
//            // 把孩子结点的值赋给父结点
//            arr[parent] = arr[lChild];
//
//            //选取孩子结点的左孩子结点,继续向下筛选
//            parent = lChild;
//            lChild = 2 * lChild + 1;
//        }
//        arr[parent] = temp;
//    }

}

</code></pre>
<h2 id="冒泡排序">冒泡排序</h2>
<h3 id="基本思想-2">基本思想</h3>
<figure data-type="image" tabindex="8"><img src="https://tinaxiawuhao.github.io/post-images/1619339811436.gif" alt="" loading="lazy"></figure>
<p>冒泡排序思路比较简单：</p>
<ul>
<li>
<ol>
<li>将序列当中的左右元素，依次比较，保证右边的元素始终大于左边的元素；</li>
</ol>
</li>
</ul>
<p>（ 第一轮结束后，序列最后一个元素一定是当前序列的最大值；）</p>
<ul>
<li>
<ol>
<li>对序列当中剩下的n-1个元素再次执行步骤1。</li>
<li>对于长度为n的序列，一共需要执行n-1轮比较</li>
</ol>
</li>
</ul>
<p>（利用while循环可以减少执行次数）</p>
<h3 id="代码实现-5">代码实现</h3>
<pre><code class="language-java">package sort;

import java.util.Arrays;

/**
 * @author wuhao
 * @desc 冒泡排序
 * @date 2020-12-02 16:34:57
 * 冒泡排序思路比较简单：
 * 将序列当中的左右元素，依次比较，保证右边的元素始终大于左边的元素；
 * （ 第一轮结束后，序列最后一个元素一定是当前序列的最大值；）
 * 对序列当中剩下的n-1个元素再次执行步骤1。
 * 对于长度为n的序列，一共需要执行n-1轮比较
 * （利用while循环可以减少执行次数）
 */
public class BubbleSort {
    public static void main(String[] args) {
        int[] arr = {12, 32, 22, 7, 48};
        bubbleSort(arr);
    }

    private static void bubbleSort(int[] arr) {
        for (int i = 0; i &lt; arr.length; i++) {
            for (int j = 0; j &lt; i; j++) {
                if (arr[i] &lt; arr[j]) {
                    int temp=arr[j];
                    arr[j]=arr[i];
                    arr[i]=temp;
                }
            }
        }
        System.out.println(Arrays.toString(arr));
    }
}

</code></pre>
<h2 id="快速排序">快速排序</h2>
<h3 id="算法思想-4">算法思想：</h3>
<figure data-type="image" tabindex="9"><img src="https://tinaxiawuhao.github.io/post-images/1619339820307.gif" alt="" loading="lazy"></figure>
<p>快速排序的基本思想：挖坑填数+分治法</p>
<ul>
<li>
<ol>
<li>从序列当中选择一个基准数(pivot)</li>
</ol>
</li>
</ul>
<p>在这里我们选择序列当中第一个数为基准数</p>
<ul>
<li>
<ol>
<li>将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧</li>
<li>重复步骤a.b，直到所有子集当中只有一个元素为止。</li>
</ol>
</li>
</ul>
<p>用伪代码描述如下：</p>
<p>1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。</p>
<p>2．j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。</p>
<p>3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。</p>
<p>4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中</p>
<h3 id="代码实现-6">代码实现：</h3>
<pre><code class="language-java">package sort;

import java.util.Arrays;
import java.util.Stack;

/**
 * @author wuhao
 * @desc 快速排序
 * @date 2020-12-02 17:08:57
 * 快速排序的基本思想：挖坑填数+分治法
 * 从序列当中选择一个基准数(pivot)
 * 在这里我们选择序列当中第一个数为基准数
 * 将序列当中的所有数依次遍历，比基准数大的位于其右侧，比基准数小的位于其左侧
 * 重复步骤a.b，直到所有子集当中只有一个元素为止。
 * 用伪代码描述如下：
 * 1．i =L; j = R; 将基准数挖出形成第一个坑a[i]。
 * 2．j--由后向前找比它小的数，找到后挖出此数填前一个坑a[i]中。
 * 3．i++由前向后找比它大的数，找到后也挖出此数填到前一个坑a[j]中。
 * 4．再重复执行2，3二步，直到i==j，将基准数填入a[i]中
 */
public class QuickSort {
    public static void main(String[] args) {
        int[] arr = {12, 32, 22, 7, 48, 3, 35, 6, 8, 42};
//        quickSort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));

        /*-----------非递归实现----------*/
        sort(arr, 0, arr.length - 1);
        System.out.println(Arrays.toString(arr));
    }

    private static void quickSort(int[] arr, int left, int right) {
        if (left &gt; right) {
            return;
        }
        // base中存放基准数
        int base = arr[left];
        int i = left, j = right;
        while (i != j) {
            // 顺序很重要，先从右边开始往左找，直到找到比base值小的数
            while (arr[j] &gt;= base &amp;&amp; i &lt; j) {
                j--;
            }

            // 再从左往右边找，直到找到比base值大的数
            while (arr[i] &lt;= base &amp;&amp; i &lt; j) {
                i++;
            }

            // 上面的循环结束表示找到了位置或者(i&gt;=j)了，交换两个数在数组中的位置
            if (i &lt; j) {
                int tmp = arr[i];
                arr[i] = arr[j];
                arr[j] = tmp;
            }
        }
        // 将基准数放到中间的位置（基准数归位）
        arr[left] = arr[i];
        arr[i] = base;

        // 递归，继续向基准的左右两边执行和上面同样的操作
        // i的索引处为上面已确定好的基准值的位置，无需再处理
        quickSort(arr, left, i - 1);
        quickSort(arr, i + 1, right);

    }


    /*-----------------------------非递归实现------------------------------*/
    public static void sort(int[] arr, int left, int right) {
        int privot, top, last;
        Stack&lt;Integer&gt; s = new Stack&lt;&gt;();
        privot = QuickSort(arr, left, right);
        if (privot &gt; left + 1) {
            s.push(left);
            s.push(privot - 1);

        }
        if (privot &lt; right - 1) {
            s.push(privot + 1);
            s.push(right);
        }
        while (!s.empty()) {
            top = s.pop();
            last = s.pop();
            privot = QuickSort(arr, last, top);
            if (privot &gt; last + 1) {
                s.push(last);
                s.push(privot - 1);
            }
            if (privot &lt; top - 1) {
                //System.out.println(top);
                s.push(privot + 1);
                s.push(top);
            }
        }
    }

    public static int QuickSort(int[] arr, int left, int right) {
        int privot = left;
        while (left &lt; right) {
            while ((arr[privot] &lt; arr[right]) &amp; left &lt; right) {
                right--;
            }
            int temp = arr[privot];
            arr[privot] = arr[right];
            arr[right] = temp;
            privot = right;

            while ((arr[privot] &gt; arr[left]) &amp; left &lt; right) {
                left++;
            }
            temp = arr[privot];
            arr[privot] = arr[left];
            arr[left] = temp;
            privot = left;
        }
        return privot;
    }
}

</code></pre>
<h2 id="归并排序">归并排序</h2>
<h3 id="算法思想-5">算法思想：</h3>
<figure data-type="image" tabindex="10"><img src="https://tinaxiawuhao.github.io/post-images/1619339833766.png" alt="" loading="lazy"></figure>
<ul>
<li>
<ol>
<li>归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用0的一个典型的应用。它的基本操作是：将已有的子序列合并，达到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。</li>
<li>归并排序其实要做两件事：</li>
</ol>
</li>
<li>
<ul>
<li>分解----将序列每次折半拆分</li>
<li>合并----将划分后的序列段两两排序合并</li>
</ul>
</li>
</ul>
<p>因此，归并排序实际上就是两个操作，拆分+合并</p>
<ul>
<li>
<ol>
<li>如何合并？</li>
</ol>
</li>
</ul>
<p>L[first...mid]为第一段，L[mid+1...last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first...last]并且也有序。</p>
<ul>
<li>
<ul>
<li>首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[]</li>
<li>重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[]</li>
<li>此时将temp[]中的元素复制给L[]，则得到的L[first...last]有序</li>
</ul>
</li>
<li>
<ol>
<li>如何分解？</li>
</ol>
</li>
</ul>
<p>在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列</p>
<p>分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。</p>
<h3 id="代码实现-7">代码实现</h3>
<pre><code class="language-java">package sort;

import java.util.Arrays;

/**
 * @author wuhao
 * @desc 归并排序
 * @date 2020-12-03 09:35:00
 * 归并排序是建立在归并操作上的一种有效的排序算法，该算法是采用0的一个典型的应用。它的基本操作是：将已有的子序列合并，达到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。
 * 归并排序其实要做两件事：
 * 分解----将序列每次折半拆分
 * 合并----将划分后的序列段两两排序合并
 * 因此，归并排序实际上就是两个操作，拆分+合并
 * 如何合并？
 * L[first...mid]为第一段，L[mid+1...last]为第二段，并且两端已经有序，现在我们要将两端合成达到L[first...last]并且也有序。
 * 首先依次从第一段与第二段中取出元素比较，将较小的元素赋值给temp[]
 * 重复执行上一步，当某一段赋值结束，则将另一段剩下的元素赋值给temp[]
 * 此时将temp[]中的元素复制给L[]，则得到的L[first...last]有序
 * 如何分解？
 * 在这里，我们采用递归的方法，首先将待排序列分成A,B两组；然后重复对A、B序列
 * 分组；直到分组后组内只有一个元素，此时我们认为组内所有元素有序，则分组结束。
 */
public class MergeSort {
    public static void main(String[] args) {
        int[] arr = {11, 44, 23, 67, 88, 65, 34, 48, 9, 12};
        int[] tmp = new int[arr.length];    //新建一个临时数组存放
        mergeSort(arr, 0, arr.length - 1, tmp);
        System.out.println(Arrays.toString(arr));
    }

    private static void mergeSort(int[] arr, int low, int high, int[] tmp) {
        if (low &lt; high) {
            int mid = (low + high) / 2;
            mergeSort(arr, low, mid, tmp);
            mergeSort(arr, mid + 1, high, tmp);
            merge(arr, low, mid, high, tmp);
        }
    }

    private static void merge(int[] arr, int low, int mid, int high, int[] tmp) {
        int i = 0;
        int j = low, k = mid + 1;
        while (j &lt;= mid &amp;&amp; k &lt;= high) {
            if (arr[j] &lt; arr[k]) {
                tmp[i++] = arr[j++];
            } else {
                tmp[i++] = arr[k++];
            }
        }
        while (j &lt;= mid) {
            tmp[i++] = arr[j++];
        }
        while (k &lt;= high) {
            tmp[i++] = arr[k++];
        }
        for (int l = 0; l &lt; i; l++) {
            arr[low+l] = tmp[l];
        }

    }
}

</code></pre>
<h2 id="基数排序">基数排序</h2>
<h3 id="算法思想-6">算法思想</h3>
<figure data-type="image" tabindex="11"><img src="https://tinaxiawuhao.github.io/post-images/1619339840696.gif" alt="" loading="lazy"></figure>
<ul>
<li>
<ol>
<li>基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。</li>
</ol>
</li>
</ul>
<p>分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中</p>
<p>收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[ ]</p>
<p>对新形成的序列L[]重复执行分配和收集元素中的十位、百位...直到分配完该序列中的最高位，则排序结束</p>
<h3 id="代码实现-8">代码实现</h3>
<pre><code class="language-java">package sort;

import java.util.Arrays;

/**
 * @author wuhao
 * @desc 基数排序
 * @date 2020-12-03 09:58:32
 * 基数排序：通过序列中各个元素的值，对排序的N个元素进行若干趟的“分配”与“收集”来实现排序。
 * 分配：我们将L[i]中的元素取出，首先确定其个位上的数字，根据该数字分配到与之序号相同的桶中
 * 收集：当序列中所有的元素都分配到对应的桶中，再按照顺序依次将桶中的元素收集形成新的一个待排序列L[ ]
 * 对新形成的序列L[]重复执行分配和收集元素中的十位、百位...直到分配完该序列中的最高位，则排序结束
 * 根据上述“基数排序”的展示，我们可以清楚的看到整个实现的过程
 */
public class BaseSort {
    public static void main(String[] args) {
        int[] arr = {63, 157, 189, 51, 101, 47, 141, 121, 157, 156,
                194, 117, 98, 139, 67, 133, 181, 12, 28, 0, 109};

        radixSort(arr);
        System.out.println(Arrays.toString(arr));
    }

    private static void radixSort(int[] arr) {
        //待排序列最大值
        int max = arr[0];
        int exp;//指数
        //计算最大值
        for (int anArr : arr) {
            if (anArr &gt; max) {
                max = anArr;
            }
        }
        //从个位开始，对数组进行排序
        for (exp = 1; max / exp &gt; 0; exp *= 10) {
            //存储待排元素的临时数组
            int[] temp = new int[arr.length];
            //分桶个数
            int[] buckets = new int[10];

            //将数据出现的次数存储在buckets中
            for (int value : arr) {
                //(value / exp) % 10 :value的最底位(个位)
                buckets[(value / exp) % 10]++;
            }

            //更改buckets[i]，
            for (int i = 1; i &lt; 10; i++) {
                buckets[i] += buckets[i - 1];
            }

            //将数据存储到临时数组temp中
            for (int i = arr.length - 1; i &gt;= 0; i--) {
                temp[buckets[(arr[i] / exp) % 10] - 1] = arr[i];
                buckets[(arr[i] / exp) % 10]--;
            }

            //将有序元素temp赋给arr
            System.arraycopy(temp, 0, arr, 0, arr.length);
        }

    }
}
</code></pre>
<h2 id="后记">后记</h2>
<p>写完之后运行了一下时间比较：</p>
<p>从运行结果上来看，堆排序、归并排序、基数排序是真的快。</p>
<p>对于快速排序迭代深度超过的问题，可以将考虑将快排通过非递归的方式进行实现。</p>

          <div class="toc-container"><ul class="markdownIt-TOC">
<li>
<ul>
<li><a href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F">直接插入排序</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3">算法思想：</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0">代码实现</a></li>
</ul>
</li>
<li><a href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F">希尔排序</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-2">算法思想：</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-2">代码实现</a></li>
</ul>
</li>
<li><a href="#%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F">简单选择排序</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-3">算法思想</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-3">代码实现</a></li>
</ul>
</li>
<li><a href="#%E5%A0%86%E6%8E%92%E5%BA%8F">堆排序</a>
<ul>
<li><a href="#%E5%A0%86%E7%9A%84%E6%A6%82%E5%BF%B5">堆的概念</a></li>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3">基本思想：</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-4">代码实现：</a></li>
</ul>
</li>
<li><a href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F">冒泡排序</a>
<ul>
<li><a href="#%E5%9F%BA%E6%9C%AC%E6%80%9D%E6%83%B3-2">基本思想</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-5">代码实现</a></li>
</ul>
</li>
<li><a href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F">快速排序</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-4">算法思想：</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-6">代码实现：</a></li>
</ul>
</li>
<li><a href="#%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F">归并排序</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-5">算法思想：</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-7">代码实现</a></li>
</ul>
</li>
<li><a href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F">基数排序</a>
<ul>
<li><a href="#%E7%AE%97%E6%B3%95%E6%80%9D%E6%83%B3-6">算法思想</a></li>
<li><a href="#%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0-8">代码实现</a></li>
</ul>
</li>
<li><a href="#%E5%90%8E%E8%AE%B0">后记</a></li>
</ul>
</li>
</ul>
</div>
          
              <hr />
            
          
            
            <p class="next-post">上一篇：
                <a href="https://tinaxiawuhao.github.io/post/yzriNkrRn/">
                  <span class="post-title">
                    Linux文件操作高频使用命令&rarr;
                  </span>
                </a>
              </p>
            
          
            
           <p class="prev-post">下一篇：
                 <a href="https://tinaxiawuhao.github.io/post/LhRxiTagh/">
                   <span class="post-title">
                     漫画：什么是B-树？&rarr;
                   </span>
                 </a>
               </p>
          
          <div class="comment" style="text-align: center;">
            

            
            
          </div>
        </div>
      </div>
  </article>
  <!-- Footer -->
  <footer>
    <div class="container">
      <div class="row">
        <div class="col-lg-8 col-md-10 mx-auto">
          <ul class="list-inline text-center">
            
            
            <li class="list-inline-item">
              <a href="https://github.com/tinaxiawuhao" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fab fa-github fa-stack-1x fa-inverse"></i>
                </span>
              </a>
            </li>
            
              
            
              
            
              
            
              
            
              
            
              
            
              
              <!-- <li class="list-inline-item">
              <a href="https://tinaxiawuhao.github.io/atom.xml" target="_blank">
                <span class="fa-stack fa-lg">
                  <i class="fas fa-circle fa-stack-2x"></i>
                  <i class="fas fa-rss fa-stack-1x fa-inverse"></i>
                </span>
              </a>
              </li> -->
          </ul>
          <p class="copyright text-muted">Copyright &copy;<span>tianxia</span><br><a href="https://github.com/getgridea/gridea" class="Themeinfo">Powered by Gridea</a></p>
        </div>
      </div>
    </div>
   </footer>
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.bootcss.com/twitter-bootstrap/4.3.1/js/bootstrap.bundle.min.js"></script>
  <!-- <script src="https://tinaxiawuhao.github.io/media/scripts/bootstrap.bundle.min.js"></script> -->
  <!-- Bootstrap core JavaScript -->
  <script src="https://cdn.jsdelivr.net/gh/Alanrk/clean-cdn@1.0/scripts/clean-blog.min.js"></script>
  <!-- <script src="https://tinaxiawuhao.github.io/media/scripts/clean-blog.min.js"></script> -->
  <style type="text/css">a.back_to_top{text-decoration:none;position:fixed;bottom:40px;right:30px;background:#f0f0f0;height:40px;width:40px;border-radius:50%;line-height:36px;font-size:18px;text-align:center;transition-duration:.5s;transition-propety:background-color;display:none}a.back_to_top span{color:#888}a.back_to_top:hover{cursor:pointer;background:#dfdfdf}a.back_to_top:hover span{color:#555}@media print,screen and(max-width:580px){.back_to_top{display:none!important}}</style>
<a id="back_to_top" href="#" class="back_to_top">
  <span>▲</span></a>
<script>$(document).ready((function(_this) {
    return function() {
      var bt;
      bt = $('#back_to_top');
      if ($(document).width() > 480) {
        $(window).scroll(function() {
          var st;
          st = $(window).scrollTop();
          if (st > 30) {
            return bt.css('display', 'block')
          } else {
            return bt.css('display', 'none')
          }
        });
        return bt.click(function() {
          $('body,html').animate({
            scrollTop: 0
          },
          800);
          return false
        })
      }
    }
  })(this));</script>
  
  <div id="landlord-parent">
    <div id="landlord">
        <div class="message" style="opacity:0"></div>
        <canvas id="live2d" width="240" height="250" class="live2d"></canvas>
    </div>
</div>

<script type="text/javascript">
    if (/(iPhone|iPad|iPod|iOS|Android)/i.test(navigator.userAgent)) {
        //移动端
        console.log("------ 移动端");
    } else {
        console.log("------ PC端 " + navigator.userAgent);

        addScript("https://cdn.jsdelivr.net/gh/850552586/ericamcdn@0.1/js/live2d.js", () => {
            // 加载完成后再loadlive2d
            loadlive2d("live2d", "https://tinaxiawuhao.github.io/media/live2d/assets/tororo.model.json");
        });

        var home_Path = "https://tinaxiawuhao.github.io/";
        addScript("https://tinaxiawuhao.github.io/media/live2d/js/message.js", () => { });
    }

    // 插入js文件，完成后callback
    function addScript(jsfile, callback) {
        var landlord_parent = document.getElementById("landlord-parent");
        var script = document.createElement("script");
        script.type = "text/javascript";
        script.src = jsfile;
        landlord_parent.appendChild(script);
        script.onload = script.onreadystatechange = function () {
            if (!this.readyState || this.readyState === "loaded" || this.readyState === "complete") {
                script.onload = script.onreadystatechange = null;
                if (callback && typeof callback == "function") {
                    callback(); //window[callback]();如果传递字符串过来 调用window['函数名']() 调用方法
                }
            }
        };
    }
</script>
  
  <script src="https://tinaxiawuhao.github.io/media/scripts/tocScript.js"></script>
</body>

</html>